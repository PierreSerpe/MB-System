<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MB-System+: MB-System Source Directory: src/mbio/</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MB-System+
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">Code for next major MB-System version, aka &quot;MB-System+&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">MB-System Source Directory: src/mbio/ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This directory contains the C source files for the libmbio library that MB-System uses to read and write seafloor mapping data in the many supported formats.</p>
<p>This document first covers the basic use of the libmbio API and then discusses structure of the source files included in this directory.</p>
<p>A document describing libmbio with a focus on how to write a new i/o module can be found at: <a href="https://www.mbari.org/wp-content/uploads/2016/03/codinganmb-systemiomodulev4.pdf">https://www.mbari.org/wp-content/uploads/2016/03/codinganmb-systemiomodulev4.pdf</a></p>
<p>These source files are copyright by David Caress and Dale Chayes and licensed using GPL3 as part of MB-System.</p>
<ul>
<li><h2>Table of Contents</h2>
</li>
</ul>
<ul>
<li></li>
</ul>
<ol type="1">
<li>MBIO Description<ol type="a">
<li>Data Terminology</li>
</ol>
<ol type="a">
<li>API Overview<ol type="i">
<li>Level 1: Simple Reading</li>
</ol>
<ol type="i">
<li>Level 2: Complete Reading and Writing</li>
</ol>
<ol type="i">
<li>Level 3: Buffered Reading and Writing</li>
</ol>
<ol type="i">
<li>Use of the Different I/O Levels</li>
</ol>
</li>
</ol>
<ol type="a">
<li>Header Files</li>
<li>I/O Modules</li>
</ol>
<ol type="a">
<li>Function Status And Error Codes</li>
</ol>
<ol type="a">
<li>Function Verbosity</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Initialization And Closing Functions<ol type="a">
<li>mb_read_init()</li>
</ol>
<ol type="a">
<li>mb_write_init()</li>
</ol>
<ol type="a">
<li>mb_register_array()</li>
</ol>
<ol type="a">
<li>mb_close()</li>
</ol>
<ol type="a">
<li>Level 1 Functions</li>
</ol>
<ol type="a">
<li>mb_read()</li>
</ol>
<ol type="a">
<li>mb_get()</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Level 2 Functions<ol type="a">
<li>mb_read_ping()</li>
</ol>
<ol type="a">
<li>mb_write_ping()</li>
</ol>
<ol type="a">
<li>mb_get_store()</li>
</ol>
<ol type="a">
<li>mb_get_all()</li>
</ol>
<ol type="a">
<li>mb_put_all()</li>
</ol>
<ol type="a">
<li>mb_put_comment()</li>
</ol>
<ol type="a">
<li>mb_extract()</li>
</ol>
<ol type="a">
<li>mb_insert()</li>
</ol>
<ol type="a">
<li>mb_extract_nav()</li>
</ol>
<ol type="a">
<li>mb_insert_nav()</li>
</ol>
<ol type="a">
<li>mb_extract_altitude()</li>
</ol>
<ol type="a">
<li>mb_insert_altitude()</li>
</ol>
<ol type="a">
<li>mb_extract_svp()</li>
</ol>
<ol type="a">
<li>mb_insert_svp()</li>
</ol>
<ol type="a">
<li>mb_ttimes()</li>
</ol>
<ol type="a">
<li>mb_detects()</li>
</ol>
<ol type="a">
<li>mb_gains()</li>
</ol>
<ol type="a">
<li>mb_extract_rawss()</li>
</ol>
<ol type="a">
<li>mb_insert_rawss()</li>
</ol>
<ol type="a">
<li>mb_copyrecord()</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Level 3 Functions<ol type="a">
<li>mb_buffer_init()</li>
</ol>
<ol type="a">
<li>mb_buffer_close()</li>
</ol>
<ol type="a">
<li>mb_buffer_load()</li>
</ol>
<ol type="a">
<li>mb_buffer_dump()</li>
</ol>
<ol type="a">
<li>mb_buffer_clear()</li>
</ol>
<ol type="a">
<li>mb_buffer_info()</li>
</ol>
<ol type="a">
<li>mb_buffer_get_next_data()</li>
</ol>
<ol type="a">
<li>mb_buffer_extract()</li>
</ol>
<ol type="a">
<li>mb_buffer_insert()</li>
</ol>
<ol type="a">
<li>mb_buffer_get_next_nav()</li>
</ol>
<ol type="a">
<li>mb_buffer_extract_nav()</li>
</ol>
<ol type="a">
<li>mb_buffer_insert_nav()</li>
</ol>
<ol type="a">
<li>mb_buffer_get_ptr()</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Miscellaneous Functions<ol type="a">
<li>mb_defaults()</li>
</ol>
<ol type="a">
<li>mb_env()</li>
</ol>
<ol type="a">
<li>mb_format()</li>
</ol>
<ol type="a">
<li>mb_format_register()</li>
</ol>
<ol type="a">
<li>mb_format_info()</li>
</ol>
<ol type="a">
<li>mb_format_system()</li>
</ol>
<ol type="a">
<li>mb_format_description()</li>
</ol>
<ol type="a">
<li>mb_format_dimensions()</li>
</ol>
<ol type="a">
<li>mb_format_flags()</li>
</ol>
<ol type="a">
<li>mb_format_source()</li>
</ol>
<ol type="a">
<li>mb_format_beamwidth()</li>
</ol>
<ol type="a">
<li>mb_datalist_open()</li>
</ol>
<ol type="a">
<li>mb_datalist_read()</li>
</ol>
<ol type="a">
<li>mb_datalist_close()</li>
</ol>
<ol type="a">
<li>mb_alloc()</li>
</ol>
<ol type="a">
<li>mb_deall()</li>
</ol>
<ol type="a">
<li>mb_error()</li>
</ol>
<ol type="a">
<li>mb_navint_add()</li>
</ol>
<ol type="a">
<li>mb_navint_interp()</li>
</ol>
<ol type="a">
<li>mb_attint_add()</li>
</ol>
<ol type="a">
<li>mb_attint_interp()</li>
</ol>
<ol type="a">
<li>mb_hedint_add()</li>
</ol>
<ol type="a">
<li>mb_hedint_interp()</li>
</ol>
<ol type="a">
<li>mb_get_double()</li>
</ol>
<ol type="a">
<li>mb_get_int()</li>
</ol>
<ol type="a">
<li>mb_get_binary_short()</li>
</ol>
<ol type="a">
<li>mb_get_binary_int()</li>
</ol>
<ol type="a">
<li>mb_get_binary_float()</li>
</ol>
<ol type="a">
<li>mb_get_binary_double()</li>
</ol>
<ol type="a">
<li>mb_put_binary_short()</li>
</ol>
<ol type="a">
<li>mb_put_binary_int()</li>
</ol>
<ol type="a">
<li>mb_put_binary_float()</li>
</ol>
<ol type="a">
<li>mb_put_binary_double()</li>
</ol>
<ol type="a">
<li>mb_get_bounds()</li>
</ol>
<ol type="a">
<li>mb_ddmmss_to_degree()</li>
</ol>
<ol type="a">
<li>mb_takeoff_to_rollpitch()</li>
</ol>
<ol type="a">
<li>mb_rollpitch_to_takeoff()</li>
</ol>
<ol type="a">
<li>mb_double_compare()</li>
</ol>
<ol type="a">
<li>mb_int_compare()</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Coordinate Systems Used In MB-System<ol type="a">
<li>Introduction</li>
</ol>
<ol type="a">
<li>Cartesian Coordinates</li>
</ol>
<ol type="a">
<li>Spherical Coordinates<ol type="i">
<li>Takeoff Angle Coordinates</li>
</ol>
<ol type="i">
<li>Roll-Pitch Coordinates</li>
</ol>
</li>
</ol>
<ol type="a">
<li>SeaBeam Coordinates</li>
</ol>
<ol type="a">
<li>Usage of Coordinate Systems in MB-System</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Beam Flags Used In MB-System</li>
</ol>
<hr  />
 <h1>### MBIO Description </h1>
<p>MBIO (**M**ulti**B**eam **I**nput/**O**utput) is a library of functions used for reading and writing swath seafloor mapping data files. This library enables processing and display programs that are independent of particular data formats and provides a standard approach to seafloor mapping data i/o.MBIO supports a large number of data formats associated with different institutions and different mapping systems, including multibean sonars, sidescan sonars, interferometric sonars, lidar, and seafloor photography. MB-System supports these heterogenous data types by layering a common application programming interface (API) on top of the I/O modules that read and write sonar data in the existing data formats. The MBIO API consists of high level functions that allow applications to open data streams for reading or writing, read and write data records sequentially, to straighforwardly extract and insert the commonly used values, and to expose the complete data representation to access. Although MB-System as a whole includes C, C++, Python, and perl source code, the MBIO library is entirely written in C.</p>
<h2>Data Terminology</h2>
<p>MBIO handles three types of swath mapping data: beam bathymetry, beam amplitude, and sidescan. Both amplitude and sidescan represent measures of backscatter strength. Beam amplitudes are backscatter values associated with the same preformed beams used to obtain bathymetry; MBIO assumes that a bathymetry value exists for each amplitude value and uses the bathymetry beam location for the amplitude. Sidescan is generally constructed with a higher spatial resolution than bathymetry, and carries its own location parameters. In the context of MB-System documentation, the discrete values of bathymetry and amplitude are referred to as "beams", and the discrete values of sidescan are referred to as "pixels". An additional difference between "beam" and "pixel" data involves data flagging. An array of "beamflags" is carried by MBIO functions which allows the bathymetry (and by extension the amplitude) data to be flagged as bad. The details of the beamflagging scheme are presented below.</p>
<h2>API Overview</h2>
<p>MBIO opens and initializes sonar data files for reading and writing using the functions mb_read_init() and mb_write_init(), respectively. These functions return a pointer to a data structure including all relevant information about the opened file, the control parameters which determine how data is read or written, and the arrays used for processing the data as it is read or written. This pointer is then passed to the functions used for reading or writing. There is no limit on the number of files which may be opened for reading or writing at any given time in a program.</p>
<p>The mb_read_init() and mb_write_init() functions also return initial maximum numbers of bathymetry beams, amplitude beams, and sidescan pixels that can be used to allocate data storage arrays of the appropriate sizes. However, for some data formats there are no specified maximum numbers of beams and pixels, and so in general the required dimensions may increase as data are read. Applications must pass appropriately dimensioned arrays into data extraction routines such as mb_read(), mb_get(), and mb_get_all(). In order to enable dynamic memory management of thse application arrays, the application must first register each array by passing the array pointer location to the function mb_register_array().</p>
<p>Data files are closed using the function mb_close(). All internal and registered arrays are deallocated as part of closing the file.</p>
<p>When it comes to actually reading and writing swath mapping sonar data, MBIO has three levels of i/o functionality:</p>
<h3>Level 1: Simple Reading</h3>
<p>The primary functions used to read and return the most basic and generic information from swath data files are:</p>
<ul>
<li>mb_read()</li>
<li>mb_get()</li>
</ul>
<p>The positions of individual beams and pixels are returned in longitude and latitude by mb_read() and in acrosstrack and alongtrack distances by mb_get(). Only a limited set of navigation information is returned. Comments are also returned. These functions can be used without any special include files or any knowledge of the actual data structures used by the data formats or MBIO.</p>
<h3>Level 2: Complete Reading and Writing</h3>
<p>These functions allow for both reading and writing of data structures containing all of the available information. Data records may be read or written without extracting any of the information, or the swath data may be passed with the data structure. Several functions exist to extract information from or insert information into the data structures; otherwise, special include files are required to make sense of the sonar-specific data structures passed by level 2 i/o functions. The basic read and write functions that only pass pointers to internal data structures are:</p>
<ul>
<li>mb_read_ping()</li>
<li>mb_write_ping()</li>
</ul>
<p>The read and write routines which also extract or insert information in form of passed variables are:</p>
<ul>
<li>mb_get_all()</li>
<li>mb_put_all()</li>
<li>mb_put_comment()</li>
</ul>
<p>The information extraction and insertion functions are:</p>
<ul>
<li>mb_insert()</li>
<li>mb_extract()</li>
<li>mb_extract_nav()</li>
<li>mb_insert_nav()</li>
<li>mb_extract_altitude()</li>
<li>mb_insert_altitude()</li>
<li>mb_ttimes()</li>
<li>mb_copyrecord()</li>
</ul>
<h3>Level 3: Buffered Reading and Writing</h3>
<p>These functions do buffered reading and writing of data structures containing all of the available information. This allows programs to read and write large numbers of data records in groups, allowing for processing operations requiring that many data records be available in memory simultaneously.</p>
<p>The primary functions are:</p>
<ul>
<li>mb_buffer_init()</li>
<li>mb_buffer_close()</li>
<li>mb_buffer_load()</li>
<li>mb_buffer_dump()</li>
<li>mb_buffer_info()</li>
<li>mb_buffer_get_next_data()</li>
<li>mb_buffer_extract()</li>
<li>mb_buffer_insert()</li>
<li>mb_buffer_get_next_nav()</li>
<li>mb_buffer_extract_nav()</li>
<li>mb_buffer_insert_nav()</li>
</ul>
<h3>Use of the Different I/O Levels</h3>
<p>The level 1 MBIO functions allow users to read sonar data independent of format, with the limitation that only a limited set of navigation information is passed. Thus, some of the information contained in certain data formats (e.g. the "heave" value in Hydrosweep DS data) is not passed by mb_read() or mb_get(). In general, the level 1 functions are useful for applications such as graphics which require only the navigation and the depth and/or backscatter values.</p>
<p>The level 2 functions (mb_get_all() and mb_put_all()) read and write the complete data structures, translate the data to internal data structures associated with each of the supported sonar systems, and pass pointers to these internal data structures. Additional functions allow a variety of information to be extracted from or inserted into the data structures (e.g. mb_extract() and mb_insert()). Additional information may be accessed using special include files to decode the data structures. The great majority of processing programs use level 2 functions.</p>
<p>The level 3 functions provide buffered reading and writing which is useful for applications that generate output files and need access to multiple pings at a time. In addition to reading (mb_buffer_load()) and writing (mb_buffer_dump()), functions exist for extracting information from the buffer (mb_buffer_extract()) and inserting information into the buffer (mb_buffer_insert()).</p>
<p>MBIO supports swath data in a number of different formats, each specified by a unique id number. The function mb_format() determines if a format id is valid. A set of similar functions returns information about the specified format (e.g. mb_format_description(), mb_format_system(), mb_format_description(), mb_format_dimensions(), mb_format_flags(), mb_format_source(), mb_format_beamwidth()).</p>
<p>Some MB-System programs can process multiple data files specified in "datalist" files. Each line of a datalist file contains a file path and the corresponding MBIO format id. Datalist files can be recursive and can contain comments. The functions used to extract input swath data file paths from datalist files includes mb_datalist_open(), mb_datalist_read(), and mb_datalist_close().</p>
<p>A number of other MBIO functions dealing with default values for important parameters, error messages, memory management, and time conversions also exist and are discussed below.</p>
<h2>Header Files</h2>
<p>There are several header files that are included by C or C++ programs calling libmbio. The header files made publicly available in an MB-System installation include:</p>
<ul>
<li>mb_config.h - Configuration file generated by the MB-System Autotools based build system. This is included by <a class="el" href="mb__define_8h.html" title="Define macros, types and functions used by MB-System.">mb_define.h</a></li>
<li><a class="el" href="mb__define_8h.html" title="Define macros, types and functions used by MB-System.">mb_define.h</a> - Defines many preprocessor macros used throughout MB-System source files, including key numeric parameters, and also includes the prototypes for all public libmbio functions. This is included by <a class="el" href="mb__io_8h.html" title="Data structures and macros used by MBIO &quot;mb_&quot; functions to store parameters relating to reading data ...">mb_io.h</a>.</li>
<li><a class="el" href="mb__status_8h.html" title="Defines version, status and error codes used.">mb_status.h</a> - Defines status values, error values, and error messages used or returned by libmbio functions. This is included by <a class="el" href="mb__io_8h.html" title="Data structures and macros used by MBIO &quot;mb_&quot; functions to store parameters relating to reading data ...">mb_io.h</a>.</li>
<li><a class="el" href="mb__process_8h.html" title="MBprocess is a tool for processing swath sonar bathymetry data.">mb_process.h</a> - Defines the <a class="el" href="structmb__preprocess__struct.html" title="structure holding mbpreprocess parameters to be passed to preprocess functions of i/o modules">mb_preprocess_struct</a> and <a class="el" href="structmb__process__struct.html" title="structure holding mbprocess parameters">mb_process_struct</a> structures that hold information defining the actions taken by programs mb_preprocess and mb_process, respectively, when processing a swath data file.</li>
<li><a class="el" href="mb__io_8h.html" title="Data structures and macros used by MBIO &quot;mb_&quot; functions to store parameters relating to reading data ...">mb_io.h</a> - Defines the <a class="el" href="structmb__io__struct.html">mb_io_struct</a> structure that holds all information involved in reading from or writing to a swath data file using libmbio. This structure includes storage of function pointers for the standard i/o functions associated with the data format being read or written. This header file includes <a class="el" href="mb__define_8h.html" title="Define macros, types and functions used by MB-System.">mb_define.h</a>, <a class="el" href="mb__status_8h.html" title="Defines version, status and error codes used.">mb_status.h</a>, and <a class="el" href="mb__process_8h.html" title="MBprocess is a tool for processing swath sonar bathymetry data.">mb_process.h</a>.</li>
<li><a class="el" href="mb__swap_8h.html" title="Macro definitions to swap 2-byte and 4-byte integers between big-endian and little-endian machines.">mb_swap.h</a> - Defines macros used to apply byte swapping when reading or writing files that use a different byte order than the current system.</li>
<li><a class="el" href="mb__format_8h.html" title="Define swath data format integer identifier codes used by MBIO functions.">mb_format.h</a> - Defines the lists and id numbers of supported data formats and format families, and includes prototypes for functions that register format modules and return basic information about the registered modules. This header file is included by <a class="el" href="mb__io_8h.html" title="Data structures and macros used by MBIO &quot;mb_&quot; functions to store parameters relating to reading data ...">mb_io.h</a>.</li>
<li><a class="el" href="mb__info_8h.html" title="Define file information and data structures used by mbproject.">mb_info.h</a> - Defines structures and function prototypes used to store geographic bounds information from metadata (*.inf) files associated with swath data files. This header file is used by programs like mbgrid, mbmosaic, mbeditviz, mbareaclean, and mbvoxelclean.</li>
<li><a class="el" href="mb__segy_8h.html" title="Defines SEG-Y trace header used when extracting seismic reflection or subbottom profiler data from sw...">mb_segy.h</a> - Defines the structures used to store time series data (usually seismic reflection) from files in the SEGY data format.</li>
</ul>
<p>There are also header files associated with the many supported data formats and the i/o modules used to read and write those formats. For most purposes, programs using libmbio access swath data through the functions described above, and do not directly access data through the structures used to store data in memory by i/o modules. The structure of the i/o modules is described below.</p>
<ul>
<li>mb_absorption.c</li>
<li>mb_access.c</li>
<li>mb_angle.c</li>
<li>mb_buffer.c</li>
<li>mb_check_info.c</li>
<li>mb_close.c</li>
<li>mb_compare.c</li>
<li>mb_coor_scale.c</li>
<li>mb_defaults.c</li>
<li>mb_error.c</li>
<li>mb_esf.c</li>
<li>mb_fileio.c</li>
<li>mb_format.c</li>
<li>mb_get.c</li>
<li>mb_get_all.c</li>
<li>mb_get_value.c</li>
<li>mb_mem.c</li>
<li>mb_navint.c</li>
<li>mb_platform.c</li>
<li>mb_platform_math.c</li>
<li>mb_process.c</li>
<li><a class="el" href="mb__proj_8c.html" title="mb_system functions to initialize and transform between projections and geographic coordinates system...">mb_proj.c</a></li>
<li>mb_put_all.c</li>
<li>mb_put_comment.c</li>
<li>mb_read.c</li>
<li>mb_read_init.c</li>
<li>mb_read_ping.c</li>
<li>mb_rt.c</li>
<li>mb_segy.c</li>
<li>mb_spline.c</li>
<li>mb_swap.c</li>
<li>mb_time.c</li>
<li>mb_write_init.c</li>
<li>mb_write_ping.c</li>
</ul>
<p>mb_config.h <a class="el" href="mb__define_8h.html" title="Define macros, types and functions used by MB-System.">mb_define.h</a> <a class="el" href="mb__format_8h.html" title="Define swath data format integer identifier codes used by MBIO functions.">mb_format.h</a> <a class="el" href="mb__info_8h.html" title="Define file information and data structures used by mbproject.">mb_info.h</a> <a class="el" href="mb__io_8h.html" title="Data structures and macros used by MBIO &quot;mb_&quot; functions to store parameters relating to reading data ...">mb_io.h</a> <a class="el" href="mb__process_8h.html" title="MBprocess is a tool for processing swath sonar bathymetry data.">mb_process.h</a> <a class="el" href="mb__segy_8h.html" title="Defines SEG-Y trace header used when extracting seismic reflection or subbottom profiler data from sw...">mb_segy.h</a> <a class="el" href="mb__status_8h.html" title="Defines version, status and error codes used.">mb_status.h</a> <a class="el" href="mb__swap_8h.html" title="Macro definitions to swap 2-byte and 4-byte integers between big-endian and little-endian machines.">mb_swap.h</a></p>
<p>mbr_3ddepthp.c</p>
<p>mbr_3dwisslp.c</p>
<p>mbr_3dwisslr.c</p>
<p>mbr_asciixyz.c</p>
<p>mbr_bchrtunb.c <a class="el" href="mbf__bchrtunb_8h_source.html">mbf_bchrtunb.h</a></p>
<p>mbr_bchrxunb.c <a class="el" href="mbf__bchrxunb_8h_source.html">mbf_bchrxunb.h</a></p>
<p>mbr_cbat8101.c <a class="el" href="mbf__cbat8101_8h_source.html">mbf_cbat8101.h</a></p>
<p>mbr_cbat9001.c <a class="el" href="mbf__cbat9001_8h_source.html">mbf_cbat9001.h</a></p>
<p>mbr_dsl120pf.c <a class="el" href="mbf__dsl120pf_8h_source.html">mbf_dsl120pf.h</a></p>
<p>mbr_dsl120sf.c <a class="el" href="mbf__dsl120sf_8h_source.html">mbf_dsl120sf.h</a></p>
<p>mbr_edgjstar.c</p>
<p>mbr_elmk2unb.c <a class="el" href="mbf__elmk2unb_8h_source.html">mbf_elmk2unb.h</a></p>
<p>mbr_em12darw.c <a class="el" href="mbf__em12darw_8h_source.html">mbf_em12darw.h</a></p>
<p>mbr_em12ifrm.c <a class="el" href="mbf__em12ifrm_8h_source.html">mbf_em12ifrm.h</a></p>
<p>mbr_em300mba.c</p>
<p>mbr_em300raw.c</p>
<p>mbr_em710mba.c</p>
<p>mbr_em710raw.c</p>
<p>mbr_emoldraw.c</p>
<p>mbr_gsfgenmb.c <a class="el" href="mbf__gsfgenmb_8h_source.html">mbf_gsfgenmb.h</a></p>
<p>mbr_hir2rnav.c</p>
<p>mbr_hs10jams.c</p>
<p>mbr_hsatlraw.c <a class="el" href="mbf__hsatlraw_8h_source.html">mbf_hsatlraw.h</a></p>
<p>mbr_hsds2lam.c</p>
<p>mbr_hsds2raw.c</p>
<p>mbr_hsldedmb.c <a class="el" href="mbf__hsldedmb_8h_source.html">mbf_hsldedmb.h</a></p>
<p>mbr_hsldeoih.c <a class="el" href="mbf__hsldeoih_8h_source.html">mbf_hsldeoih.h</a></p>
<p>mbr_hsmdaraw.c <a class="el" href="mbf__hsmdaraw_8h_source.html">mbf_hsmdaraw.h</a></p>
<p>mbr_hsmdldih.c <a class="el" href="mbf__hsmdldih_8h_source.html">mbf_hsmdldih.h</a></p>
<p>mbr_hsunknwn.c</p>
<p>mbr_hsuricen.c <a class="el" href="mbf__hsuricen_8h_source.html">mbf_hsuricen.h</a></p>
<p>mbr_hsurivax.c</p>
<p>mbr_hydrob93.c</p>
<p>mbr_hypc8101.c <a class="el" href="mbf__hypc8101_8h_source.html">mbf_hypc8101.h</a></p>
<p>mbr_hysweep1.c</p>
<p>mbr_image83p.c</p>
<p>mbr_imagemba.c</p>
<p>mbr_kemkmall.c</p>
<p>mbr_l3xseraw.c</p>
<p>mbr_mbarimb1.c</p>
<p>mbr_mbarirov.c <a class="el" href="mbf__mbarirov_8h_source.html">mbf_mbarirov.h</a></p>
<p>mbr_mbarrov2.c <a class="el" href="mbf__mbarrov2_8h_source.html">mbf_mbarrov2.h</a></p>
<p>mbr_mbldeoih.c</p>
<p>mbr_mbnetcdf.c</p>
<p>mbr_mbpronav.c <a class="el" href="mbf__mbpronav_8h_source.html">mbf_mbpronav.h</a></p>
<p>mbr_mgd77dat.c <a class="el" href="mbf__mgd77dat_8h_source.html">mbf_mgd77dat.h</a></p>
<p>mbr_mgd77tab.c</p>
<p>mbr_mgd77txt.c</p>
<p>mbr_mr1aldeo.c <a class="el" href="mbf__mr1aldeo_8h_source.html">mbf_mr1aldeo.h</a></p>
<p>mbr_mr1bldeo.c <a class="el" href="mbf__mr1bldeo_8h_source.html">mbf_mr1bldeo.h</a></p>
<p>mbr_mr1prhig.c <a class="el" href="mbf__mr1prhig_8h_source.html">mbf_mr1prhig.h</a></p>
<p>mbr_mr1prvr2.c</p>
<p>mbr_mstiffss.c <a class="el" href="mbf__mstiffss_8h_source.html">mbf_mstiffss.h</a></p>
<p>mbr_nvnetcdf.c</p>
<p>mbr_oicgeoda.c <a class="el" href="mbf__oicgeoda_8h_source.html">mbf_oicgeoda.h</a></p>
<p>mbr_oicmbari.c <a class="el" href="mbf__oicmbari_8h_source.html">mbf_oicmbari.h</a></p>
<p>mbr_omghdcsj.c <a class="el" href="mbf__omghdcsj_8h_source.html">mbf_omghdcsj.h</a></p>
<p>mbr_photgram.c</p>
<p>mbr_reson7k3.c</p>
<p>mbr_reson7kr.c</p>
<p>mbr_samesurf.c</p>
<p>mbr_segysegy.c</p>
<p>mbr_swplssxi.c</p>
<p>mbr_swplssxp.c</p>
<p>mbr_tempform.c</p>
<p>mbr_wasspenl.c</p>
<p>mbr_xtfb1624.c</p>
<p>mbr_xtfr8101.c <a class="el" href="mbf__xtfr8101_8h_source.html">mbf_xtfr8101.h</a></p>
<p>mbsys_3datdepthlidar.c <a class="el" href="mbsys__3datdepthlidar_8h_source.html">mbsys_3datdepthlidar.h</a></p>
<p>mbsys_3ddwissl.c <a class="el" href="mbsys__3ddwissl_8h_source.html">mbsys_3ddwissl.h</a></p>
<p>mbsys_atlas.c <a class="el" href="mbsys__atlas_8h.html" title="Defines the MBIO data structures for handling data from STN Atlas Marine Electronics multibeam sonars...">mbsys_atlas.h</a></p>
<p>mbsys_benthos.c <a class="el" href="mbsys__benthos_8h.html" title="Define the data structures used by MBIO functions to store data from Benthos SIS1624 Sidescan sonar s...">mbsys_benthos.h</a></p>
<p>mbsys_dsl.c <a class="el" href="mbsys__dsl_8h_source.html">mbsys_dsl.h</a></p>
<p>mbsys_elac.c <a class="el" href="mbsys__elac_8h_source.html">mbsys_elac.h</a></p>
<p>mbsys_elacmk2.c <a class="el" href="mbsys__elacmk2_8h_source.html">mbsys_elacmk2.h</a></p>
<p>mbsys_gsf.c <a class="el" href="mbsys__gsf_8h_source.html">mbsys_gsf.h</a></p>
<p>mbsys_hdcs.c <a class="el" href="mbsys__hdcs_8h_source.html">mbsys_hdcs.h</a></p>
<p>mbsys_hs10.c <a class="el" href="mbsys__hs10_8h_source.html">mbsys_hs10.h</a></p>
<p>mbsys_hsds.c <a class="el" href="mbsys__hsds_8h_source.html">mbsys_hsds.h</a></p>
<p>mbsys_hsmd.c <a class="el" href="mbsys__hsmd_8h_source.html">mbsys_hsmd.h</a></p>
<p>mbsys_hysweep.c <a class="el" href="mbsys__hysweep_8h_source.html">mbsys_hysweep.h</a></p>
<p>mbsys_image83p.c <a class="el" href="mbsys__image83p_8h_source.html">mbsys_image83p.h</a></p>
<p>mbsys_jstar.c <a class="el" href="mbsys__jstar_8h_source.html">mbsys_jstar.h</a> <a class="el" href="mbsys__jstar2_8h_source.html">mbsys_jstar2.h</a></p>
<p>mbsys_kmbes.c <a class="el" href="mbsys__kmbes_8h_source.html">mbsys_kmbes.h</a></p>
<p>mbsys_ldeoih.c <a class="el" href="mbsys__ldeoih_8h_source.html">mbsys_ldeoih.h</a></p>
<p>mbsys_mr1.c <a class="el" href="mbsys__mr1_8h_source.html">mbsys_mr1.h</a></p>
<p>mbsys_mr1b.c <a class="el" href="mbsys__mr1b_8h_source.html">mbsys_mr1b.h</a></p>
<p>mbsys_mr1v2001.c <a class="el" href="mbsys__mr1v2001_8h_source.html">mbsys_mr1v2001.h</a></p>
<p>mbsys_mstiff.c <a class="el" href="mbsys__mstiff_8h_source.html">mbsys_mstiff.h</a></p>
<p>mbsys_navnetcdf.c <a class="el" href="mbsys__navnetcdf_8h_source.html">mbsys_navnetcdf.h</a></p>
<p>mbsys_netcdf.c <a class="el" href="mbsys__netcdf_8h_source.html">mbsys_netcdf.h</a></p>
<p>mbsys_oic.c <a class="el" href="mbsys__oic_8h_source.html">mbsys_oic.h</a></p>
<p>mbsys_reson.c <a class="el" href="mbsys__reson_8h_source.html">mbsys_reson.h</a></p>
<p>mbsys_reson7k.c <a class="el" href="mbsys__reson7k_8h_source.html">mbsys_reson7k.h</a></p>
<p>mbsys_reson7k3.c <a class="el" href="mbsys__reson7k3_8h_source.html">mbsys_reson7k3.h</a></p>
<p>mbsys_reson8k.c <a class="el" href="mbsys__reson8k_8h_source.html">mbsys_reson8k.h</a></p>
<ul>
<li><b>Data System "SB"</b><ul>
<li>SeaBeam Classic multibeam<ul>
<li>mbsys_sb.c</li>
<li><a class="el" href="mbsys__sb_8h_source.html">mbsys_sb.h</a></li>
</ul>
</li>
<li>Format SBSIOMRG 11<ul>
<li>mbr_sbsiomrg.c</li>
<li><a class="el" href="mbf__sbsiomrg_8h_source.html">mbf_sbsiomrg.h</a></li>
</ul>
</li>
<li>Format SBSIOCEN 12<ul>
<li>mbr_sbsiocen.c</li>
<li><a class="el" href="mbf__sbsiocen_8h_source.html">mbf_sbsiocen.h</a></li>
</ul>
</li>
<li>Format SBSIOLSI 13<ul>
<li>mbr_sbsiolsi.c</li>
<li><a class="el" href="mbf__sbsiolsi_8h_source.html">mbf_sbsiolsi.h</a></li>
</ul>
</li>
<li>Format SBURICEN 14<ul>
<li>mbr_sburicen.c</li>
<li><a class="el" href="mbf__sburicen_8h_source.html">mbf_sburicen.h</a></li>
</ul>
</li>
<li>Format SBURIVAX 15<ul>
<li>mbr_sburivax.c</li>
</ul>
</li>
<li>Format SBSIOSWB 16<ul>
<li>mbr_sbsioswb.c</li>
<li><a class="el" href="mbf__sbsioswb_8h_source.html">mbf_sbsioswb.h</a></li>
</ul>
</li>
<li>Format SBIFREMR 17<ul>
<li>mbr_sbifremr.c</li>
<li><a class="el" href="mbf__sbifremr_8h_source.html">mbf_sbifremr.h</a></li>
</ul>
</li>
</ul>
</li>
<li><b>Data System "HSDS"</b><ul>
<li>Atlas Hydrosweep DS multibeam<ul>
<li>mbsys_hsds.c</li>
<li><a class="el" href="mbsys__hsds_8h_source.html">mbsys_hsds.h</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>mbr_sb2000sb.c</p>
<p>mbr_sb2000ss.c</p>
<p>mbr_sb2100bi.c</p>
<p>mbr_sb2100rw.c <a class="el" href="mbf__sb2100rw_8h_source.html">mbf_sb2100rw.h</a></p>
<p><a class="el" href="mbf__sb2120xs_8h_source.html">mbf_sb2120xs.h</a></p>
<p>mbsys_sb2000.c <a class="el" href="mbsys__sb2000_8h_source.html">mbsys_sb2000.h</a></p>
<p>mbsys_sb2100.c <a class="el" href="mbsys__sb2100_8h_source.html">mbsys_sb2100.h</a></p>
<p>mbsys_simrad.c <a class="el" href="mbsys__simrad_8h_source.html">mbsys_simrad.h</a></p>
<p>mbsys_simrad2.c <a class="el" href="mbsys__simrad2_8h_source.html">mbsys_simrad2.h</a></p>
<p>mbsys_simrad3.c <a class="el" href="mbsys__simrad3_8h_source.html">mbsys_simrad3.h</a></p>
<p>mbsys_singlebeam.c <a class="el" href="mbsys__singlebeam_8h_source.html">mbsys_singlebeam.h</a></p>
<p>mbsys_stereopair.c <a class="el" href="mbsys__stereopair_8h_source.html">mbsys_stereopair.h</a></p>
<p>mbsys_surf.c <a class="el" href="mbsys__surf_8h_source.html">mbsys_surf.h</a></p>
<p>mbsys_swathplus.c <a class="el" href="mbsys__swathplus_8h_source.html">mbsys_swathplus.h</a></p>
<p>mbsys_templatesystem.c <a class="el" href="mbsys__templatesystem_8h_source.html">mbsys_templatesystem.h</a></p>
<p>mbsys_wassp.c <a class="el" href="mbsys__wassp_8h_source.html">mbsys_wassp.h</a></p>
<p>mbsys_xse.c <a class="el" href="mbsys__xse_8h_source.html">mbsys_xse.h</a></p>
<p>projections.h</p>
<h2>I/O Modules</h2>
<p>In order to support as broad a range of mapping data as possible without losing information, and to allow for advances in the remote sensing technology we use, we have architected MB-System to read and write data in the existing formats and to store those data internally with all information preserved. The consequence is that the MB-System input and output capability is isolated to this modular library (MBIO) supporting dozens of different seafloor mapping data formats. Each unique format is associated with an integer identifier number and with functions that read the data into an internal representation, or data system, and write from that representation. A second level of modularity includes the many different data systems that are supported; each data system is defined by a structure used to store the data and a set of functions that extract commonly used values from, or insert values into, that structure. <br  />
</p>
<p>In the terminology of this document, each MBIO I/O module consists of a single data system and at least one data format. Each data system includes both a structure to store the data and functions that map commonly used values to and from that structure. The data format includes functions that read and write the data to and from the data structure of the associated data system. The data systems are defined by two source files each: a header file with a name of the form mbsys_XXX.h that defines the structure used to store the data and a C file with a name of the form mbsys_XXX.c that includes all of the functions used to extract information from or insert information into the storage structure. Here "XXX" is the data system name, which may be any number of characters. The data formats are defined in C files with names of the form mbr_YYYYYYYY.c that include the functions to read and write data files in that format, translating the data into and out of the representation structure in mbsys_XXX.h. Here "YYYYYYYY" is the data format name, which is always eight characters long.</p>
<p>As an example, the Kongsberg third generation multibeam data format is supported with two data formats, the raw or vendor format logged by the sonars, and an extended format defined for MB-System processing. The data system name is "simrad3", and the format names and numeric id's are "em710raw" and 58 for the vendor format and "em710mba" and 59 for the extended format. The source files associated with these two formats are:</p>
<ul>
<li><a class="el" href="mbsys__simrad3_8h_source.html">mbsys_simrad3.h</a></li>
<li>mbsys_simrad3.c</li>
<li>mbr_em710raw.c</li>
<li>mbr_em710mba.c</li>
</ul>
<p>In some cases, data formats include structure definitions used while translating data from the files to and from the data system representation; these structures are found in files with names of the form mbf_YYYYYYYY.h.</p>
<p>Several data formats depend on lower level libraries such as XDR or NetCDF for i/o. Others depend on high level libraries such Generic Sensor Format (GSF) or BSIO that are included in separate source directories within the MB-System package.</p>
<h2>Function Status And Error Codes</h2>
<p>All of the MBIO functions return an integer status value with the convention that:</p>
<ul>
<li>status = 1: success</li>
<li>status = 0: failure</li>
</ul>
<p>All MBIO functions also pass an error value argument which gives some- what more information about problems than the status value. The full suite of possible error values and the associated error messages are:</p>
<ul>
<li>error = 0: "No error",</li>
<li>error = -1: "Time gap in data",</li>
<li>error = -2: "Data outside specified location bounds",</li>
<li>error = -3: "Data outside specified time interval",</li>
<li>error = -4: "Ship speed too small",</li>
<li>error = -5: "Comment record",</li>
<li>error = -6: "Neither a data record nor a comment record",</li>
<li>error = -7: "Unintelligible data record",</li>
<li>error = -8: "Ignore this data",</li>
<li>error = -9: "No data requested for buffer load",</li>
<li>error = -10: "Data buffer is full",</li>
<li>error = -11: "No data was loaded into the buffer",</li>
<li>error = -12: "Data buffer is empty",</li>
<li>error = -13: "No data was dumped from the buffer"</li>
<li>error = -14: "No more survey data records in buffer"</li>
<li>error = -15: "Data inconsistencies prevented inserting data into storage structure"</li>
<li>error = 1: "Unable to allocate memory, initialization failed",</li>
<li>error = 2: "Unable to open file, initialization failed",</li>
<li>error = 3: "Illegal format identifier, initialization failed",</li>
<li>error = 4: "Read error, probably end-of-file",</li>
<li>error = 5: "Write error",</li>
<li>error = 6: "No data in specified location bounds",</li>
<li>error = 7: "No data in specified time interval",</li>
<li>error = 8: "Invalid MBIO descriptor",</li>
<li>error = 9: "Inconsistent usage of MBIO descriptor",</li>
<li>error = 10: "No pings binned but no fatal error - this should not happen!",</li>
<li>error = 11: "Invalid data record type specified for writing",</li>
<li>error = 12: "Invalid control parameter specified by user",</li>
<li>error = 13: "Invalid buffer id",</li>
<li>error = 14: "Invalid system id - this should not happen!"</li>
<li>error = 15: "This data file is not in the specified format!"</li>
</ul>
<p>In general, programs should treat negative error values as non-fatal (reading and writing can continue) and positive error values as fatal (the data files should be closed and the program terminated).</p>
<h2>Function Verbosity</h2>
<p>All of the MBIO functions are passed a verbose parameter which controls how much debugging information is output to standard error. If verbose is 0 or 1, the MBIO functions will be silent. If verbose is 2, then each function will output information as it is entered and as it returns, along with the parameter values passed into and returned out of the function. Greater values of verbose will cause additional information to be output, including values at various stages of data processing during read and write operations. In general, programs using MBIO functions should adopt the following verbosity conventions:</p>
<ul>
<li>verbose = 0: "silent" or near-"silent" execution</li>
<li>verbose = 1: simple output including program name, version and simple progress updates</li>
<li>verbose &gt;= 2: debug mode with copious output including every function call and status listings</li>
</ul>
<h2>Initialization And Closing Functions</h2>
<h3>mb_read_init()</h3>
<pre class="fragment">int mb_read_init(
             int verbose,
             char *file,
             int format,
             int pings,
             int lonflip,
             double bounds[4],
             int btime_i[7],
             int etime_i[7],
             double speedmin,
             double timegap,
             char **mbio_ptr,
             double *btime_d,
             double *etime_d,
             int *beams_bath,
             int *beams_amp,
             int *pixels_ss,
             int *error);
</pre><p> The function mb_read_init initializes the data file to be read and the data structures required for reading the data. The verbose value controls the standard error output verbosity of the function.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>file: input filename</li>
<li>format: input MBIO data format id</li>
<li>pings: ping averaging</li>
<li>lonflip: longitude flipping</li>
<li>bounds: location bounds of acceptable data</li>
<li>btime_i: beginning time of acceptable data</li>
<li>etime_i: ending time of acceptable data</li>
<li>speedmin: minimum ship speed of acceptable data</li>
<li>timegap: maximum time allowed before data gap</li>
</ul>
<p>The format identifier format specifies which of the supported data for- mats is being read or written; the currently supported formats are listed in the "SUPPORTED FORMATS" section.</p>
<p>The pings parameter determines whether and how pings are averaged as part of data input. This parameter is used only by the functions mb_read and mb_get; mb_get_all and mb_buffer_load do not average pings. If pings = 1, then no ping averaging will be done and each ping read will be returned unaltered by the reading function. If pings &gt; 1, then the navigation and beam data for pings pings will be read, averaged, and returned as the data for a single ping. If pings = 0, then the ping averaging will be varied so that the along-track distance between averaged pings is as close as possible to the across-track distance between beams.</p>
<p>The lonflip paramenter determines the range in which longitude values are returned:</p>
<ul>
<li>lonflip = -1 : -360 to 0</li>
<li>lonflip = 0 : -180 to 180</li>
<li>lonflip = 1 : 0 to 360</li>
</ul>
<p>The bounds array sets the area within which data are desired. Data which lie outside the area specified by bounds will be returned with an error by the reading function. The functions mb_read, mb_get and mb_get_all use the bounds array; the function mb_buffer_load does no location checking.</p>
<ul>
<li>bounds[0] : minimum longitude</li>
<li>bounds[1] : maximum longitude</li>
<li>bounds[2] : minimum latitude</li>
<li>bounds[3] : maximum latitude</li>
</ul>
<p>The btime_i array sets the desired beginning time for the data and the etime_i array sets the desired ending time. If the beginning time is earlier than the ending time, then any data with a time stamp before the beginning time or after the ending time will be returned with an MB_ERROR_OUT_TIME error by the reading function. If the beginning time is after the ending time, then data with time stamps between the ending and beginning time are returned with an error. This scheme allows time windowing outside or inside a specified interval. The functions mb_read, mb_get and mb_get_all use the btime_i and btime_i arrays; the function mb_buffer_load does no time checking.</p>
<ul>
<li>btime[0] : year</li>
<li>btime[1] : month</li>
<li>btime[2] : day</li>
<li>btime[3] : hour</li>
<li>btime[4] : minute</li>
<li>btime[5] : second</li>
<li>btime[6] : microsecond</li>
<li>etime[0] : year</li>
<li>etime[1] : month</li>
<li>etime[2] : day</li>
<li>etime[3] : hour</li>
<li>etime[4] : minute</li>
<li>etime[5] : second</li>
<li>etime[6] : microsecond</li>
</ul>
<p>The speedmin parameter sets the minimum acceptable ship speed for the data. If the ship speed associated with any ping is less than speed- min, then that data will be returned with an error by the reading func- tion. This is used to eliminate data collected while a ship is on sta- tion is a simple way. The functions mb_read, mb_get and mb_get_all use the speedmin value; the function mb_buffer_load does no speed checking.</p>
<p>The timegap parameter sets the minimum time gap allowed before a gap in the data is declared. Ping averaging is not done across data gaps; an error is returned when time gaps are encountered. The functions mb_read and mb_get use the timegap value; the functions mb_get_all and mb_buffer_load do no ping averaging and thus have no need to check for time gaps.</p>
<p>The returned values are:</p>
<ul>
<li>mbio_ptr: pointer to an MBIO descriptor structure</li>
<li>btime_d: desired beginning time in seconds</li>
<li>since 1/1/70 00:00:0</li>
<li>etime_d: desired ending time in seconds</li>
<li>since 1/1/70 00:00:0</li>
<li>beams_bath: maximum number of bathymetry beams</li>
<li>beams_amp: maximum number of amplitude beams</li>
<li>pixels_ss: maximum number of sidescan pixels</li>
<li>error: error value</li>
</ul>
<p>The structure pointed to by mbio_ptr holds the file descriptor and all of the control parameters which govern how the data is read; this pointer must be provided to the functions mb_read, mb_get, mb_get_all, or mb_buffer_load to read data. The values beams_bath, beams_amp, and pixels_ss return initial estimates of the maximum number of bathymetry and amplitude beams and sidescan pixels, respectively, that the speci- fied data format may contain. In general, beams_amp will either be zero or equal to beams_bath. The values btime_d and etime_d give the desired beginning and end times of the data converted to seconds since 00:00:00 on January 1, 1970; MBIO uses these units to calculate time internally.</p>
<p>For most data formats, the initial maximum beam and pixel dimensions will not change. However, a few formats support both variable and arbitrarily large numbers of beams and/or pixels, and so applications must be capable of handling dynamic changes in the numbers of beams and pixels. The arrays allocated internally in the mbio_ptr structure are automatically increased when necessary. However, in order to success- fully extract swath data using mb_get, mb_get_all, mb_read, or mb_extract, an application must also provide pointers to arrays large enough to hold the current maximum numbers of bathymetry beams, ampli- tude beams, and sidescan pixels. The function mb_register_ioarray allows applications to register array pointers so that these arrays are also dynamically allocated by MBIO. Registered arrays will be managed as data are read and then freed when mb_close is called.</p>
<p>A status value indicating success or failure is returned; an error value argument passes more detailed information about initialization failures.</p>
<h3>mb_write_init()</h3>
<pre class="fragment">int mb_write_init(
     int verbose,
     char *file,
     int format,
     char **mbio_ptr,
     int *beams_bath,
     int *beams_amp,
     int *pixels_ss,
     int *error);
</pre><p> The function mb_write_init initializes the data file to be written and the data structures required for writing the data. The verbose value controls the standard error output verbosity of the function.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>file: output filename</li>
<li>format: output MBIO data format id</li>
</ul>
<p>The returned values are:</p>
<ul>
<li>mbio_ptr: pointer to a structure describing the output file</li>
<li>beams_bath: maximum number of bathymetry beams</li>
<li>beams_back: maximum number of backscatter beams</li>
<li>error: error value</li>
</ul>
<p>The structure pointed to by mbio_ptr holds the output file descriptor; this pointer must be provided to the functions mb_write, mb_put, mb_put_all, or mb_buffer_dump to write data. The values beams_bath, beams_amp, and pixels_ss return the maximum number of bathymetry and amplitude beams and sidescan pixels, respectively, that the specified data format may contain. In general, beams_amp will either be zero or equal to beams_bath. In order to successfully write data, the calling program must provide pointers to arrays large enough to hold beams_bath bathymetry values, beams_amp amplitude values, and pixels_ss sidescan values.</p>
<p>For most data formats, the initial maximum beam and pixel dimensions will not change. However, a few formats support both variable and arbitrarily large numbers of beams and/or pixels, and so applications must be capable of handling dynamic changes in the numbers of beams and pixels. The arrays allocated internally in the mbio_ptr structure are automatically increased when necessary. However, in order to successfully insert modified swath data using mb_put, mb_put_all, or mb_insert, an application must also provide pointers to arrays large enough to hold the current maximum numbers of bathymetry beams, amplitude beams, and sidescan pixels. The function mb_register_ioarray allows applications to register array pointers so that these arrays are also dynamically allocated by MBIO. Registered arrays will be managed as data are read and written and then freed when mb_close is called.</p>
<p>A status value indicating success or failure is returned; an error value argument passes more detailed information about initialization failures.</p>
<h3>mb_register_array()</h3>
<pre class="fragment">int mb_register_array(
     int verbose,
     void *mbio_ptr,
     int type,
     int size,
     void **handle,
     int *error)
</pre><p> Registers an array pointer *handle so that the size of the allocated array can be managed dynamically by MBIO. Note that the location **handle of the array pointer must be supplied, not the pointer value *handle. The pointer value *handle should initially be NULL. The type value indicates whether this array is to be dimensioned according to the maximum number of bathymetry beams (type = 1), amplitude beams (type = 2), or sidescan pixels (type = 3). The size value indicates the size of each element array in bytes (e.g. a char array has size = 1, a short array has size = 2, an int array or a float array have size = 4, and a double array has size = 8). The array is associated with the MBIO descriptor mbio_ptr, and is freed when mb_close is called for this par- ticular mbio_ptr.</p>
<h3>mb_close()</h3>
<pre class="fragment">int mb\_close(
     int verbose,
     char *mbio\_ptr,
     int *error)
</pre><p> Closes the data file listed in the MBIO descriptor pointed to by mbio_ptr and releases all specially allocated memory, including all application arrays registered using mb_register_array. The verbose value controls the standard error output verbosity of the function. A status value indicating success or failure is returned; an error value argument passes more detailed information about failures.</p>
<h2>Level 1 Functions</h2>
<h3>mb_read()</h3>
<pre class="fragment">int mb_read(
     int verbose,
     char *mbio_ptr,
     int *kind,
     int *pings,
     int time_i[7],
     double *time\_d,
     double *navlon,
     double *navlat,
     double *speed,
     double *heading,
     double *distance,
     double *altitude,
     double *sonardepth,
     int *nbath,
     int *namp,
     int *nss,
     char *beamflag,
     double *bath,
     double *amp,
     double *bathlon,
     double *bathlat,
     double *ss,
     double *sslon,
     double *sslat,
     char *comment,
     int *error);
</pre><p> The function mb_read reads, processes, and returns sonar data according to the MBIO descriptor pointed to by mbio_ptr. The verbose value con- trols the standard error output verbosity of the function. A number of different data record types are recognized by MB-System, but mb_read() only returns survey and comment data records. The kind value indicates which type of record has been read. The data is in the form of bathym- etry, amplitude, and sidescan values combined with the longitude and latitude locations of the bathymetry and sidescan measurements (ampli- tudes are coincident with the bathymetry).</p>
<p>The return values are:</p>
<ul>
<li>kind: kind of data record read<ul>
<li>1 survey data</li>
<li>2 comment</li>
<li>&gt;=3 other data that cannot be passed by mb_read</li>
</ul>
</li>
<li>pings: number of pings averaged to give current data</li>
<li>time_i: time of current ping<ul>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
</ul>
</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>distance: distance along shiptrack since last ping in km</li>
<li>altitude: altitude of sonar above seafloor in m</li>
<li>sonardepth: depth of sonar in m</li>
<li>nbath: number of bathymetry values</li>
<li>namp: number of amplitude values</li>
<li>nss: number of sidescan values</li>
<li>beamflag: array of bathymetry flags</li>
<li>bath: array of bathymetry values in meters</li>
<li>amp: array of amplitude values in unknown units</li>
<li>bathlon: array of of longitude values corresponding to bathymetry</li>
<li>bathlat: array of of latitude values corresponding to bathymetry</li>
<li>ss: array of sidescan values in unknown units</li>
<li>sslon: array of of longitude values corresponding to sidescan</li>
<li>sslat: array of of latitude values corresponding to sidescan</li>
<li>comment: comment string</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about read failures.</p>
<h3>mb_get()</h3>
<pre class="fragment">int mb_get(
     int verbose,
     char *mbio_ptr,
     int *kind,
     int *pings,
     int time_i[7],
     double *time\_d,
     double *navlon,
     double *navlat,
     double *speed,
     double *heading,
     double *distance,
     double *altitude,
     double *sonardepth,
     int *nbath,
     int *namp,
     int *nss,
     char *beamflag,
     double *bath,
     double *amp,
     double *bathacrosstrack,
     double *bathalongtrack,
     double *ss,
     double *ssacrosstrack,
     double *ssalongtrack,
     char *comment,
     int *error);
</pre><p> The function mb_get reads, processes, and returns sonar data according to the MBIO descriptor pointed to by mbio_ptr. The verbose value con- trols the standard error output verbosity of the function. A number of different data record types are recognized by MB-System, but mb_get() only returns survey and comment data records. The kind value indicates which type of record has been read. The data is in the form of bathym- etry, amplitude, and sidescan values combined with the acrosstrack and alongtrack distances relative to the navigation of the bathymetry and sidescan measurements (amplitudes are coincident with the bathymetry values).</p>
<p>The return values are:</p>
<ul>
<li>kind: kind of data record read<ul>
<li>1 survey data</li>
<li>2 comment</li>
<li>&gt;=3 other data that cannot be passed by mb_get</li>
</ul>
</li>
<li>pings: number of pings averaged to give current data</li>
<li>time_i: time of current ping<ul>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
</ul>
</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>distance: distance along shiptrack since last ping in km</li>
<li>altitude: altitude of sonar above seafloor in m</li>
<li>sonardepth: depth of sonar in m</li>
<li>nbath: number of bathymetry values</li>
<li>namp: number of amplitude values</li>
<li>nss: number of sidescan values</li>
<li>beamflag: array of bathymetry flags</li>
<li>bath: array of bathymetry values in meters</li>
<li>amp: array of amplitude values in unknown units</li>
<li>bathacrosstrack: array of of acrosstrack distances in meters corresponding to bathymetry</li>
<li>bathalongtrack: array of of alongtrack distances in meters corresponding to bathymetry</li>
<li>ss: array of sidescan values in unknown units</li>
<li>ssacrosstrack: array of of acrosstrack distances in meters corresponding to sidescan</li>
<li>ssacrosstrack: array of of alongtrack distances in meters corresponding to sidescan</li>
<li>comment: comment string</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about read fail- ures.</p>
<h2>Level 2 Functions</h2>
<h3>mb_read_ping()</h3>
<pre class="fragment">int mb_read_ping(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int *kind,
     int *error);
</pre><p> The function mb_read_ping reads and returns sonar data according to the MBIO descriptor pointed to by mbio_ptr. The verbose value controls the standard error output verbosity of the function. The data is returned one record at a time; no averaging is performed. A pointer to a data structure containing all of the data read is returned as store_ptr; the form of the data structure is determined by the sonar system associated with the format of the data being read. A number of different data record types are recognized by MB-System; the kind value indicates which type of record has been read.</p>
<p>The return values are:</p>
<ul>
<li>store_ptr: pointer to complete data structure</li>
<li>kind: kind of data record read<ul>
<li>1 survey data</li>
<li>2 comment</li>
<li>3 header</li>
<li>4 calibrate</li>
<li>5 mean sound speed</li>
<li>6 SVP</li>
<li>7 standby</li>
<li>8 nav source</li>
<li>9 parameter</li>
<li>10 start</li>
<li>11 stop</li>
<li>12 nav</li>
<li>13 run parameter</li>
<li>14 clock</li>
<li>15 tide</li>
<li>16 height</li>
<li>17 heading</li>
<li>18 attitude</li>
<li>19 ssv</li>
<li>20 angle</li>
<li>21 event</li>
<li>22 history</li>
<li>23 summary</li>
<li>24 processing parameters</li>
<li>25 sensor parameters</li>
<li>26 navigation error</li>
<li>27 uninterpretable line</li>
</ul>
</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about read fail- ures.</p>
<h3>mb_write_ping()</h3>
<pre class="fragment">int mb_write_ping(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int *error);
</pre><p> The function mb_write_ping writes sonar data to the file listed in the MBIO descriptor pointed to by MBIO_ptr. The verbose value controls the standard error output verbosity of the function. A pointer to a data structure containing all of the data read is passed as store_ptr; the form of the data structure is determined by the sonar system associated with the format of the data being written. The values to be output are:</p>
<ul>
<li>store_ptr: pointer to complete data structure</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about write failures.</p>
<h3>mb_get_store()</h3>
<pre class="fragment">int mb_get_store(
     int verbose,
     char *mbio_ptr,
     char **store_ptr,
     int *error);
</pre><p> The function mb_get_store() returns a pointer *store_ptr to the data storage structure associated with a particular MBIO descriptor mbio_ptr. The mb_read_init() and mb_write_init() functions both allocate one of these internal storage structures. The form of the data structure is determined by the sonar system associated with the format of the data being written. Storage structure pointers must be passed to level two MBIO functions such as mb_write_ping() and mb_insert(). The verbose value controls the standard error output verbosity of the function.</p>
<p>The return values are:</p>
<ul>
<li>store_ptr: pointer to complete data structure</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_get_all()</h3>
<pre class="fragment">int mb_get_all(
     int verbose,
     char *mbio_ptr,
     char **store_ptr,
     int *kind,
     int time_i[7],
     double *time_d,
     double *navlon,
     double *navlat,
     double *speed,
     double *heading,
     double *distance,
     double *altitude,
     double *sonardepth,
     int *nbath,
     int *namp,
     int *nss,
     char *beamflag,
     double *bath,
     double *amp,
     double *bathacrosstrack,
     double *bathalongtrack,
     double *ss,
     double *ssacrosstrack,
     double *ssalongtrack,
     char *comment,
     int *error);
</pre><p> The function mb_get_all reads and returns sonar data according to the MBIO descriptor pointed to by mbio_ptr. The verbose value controls the standard error output verbosity of the function. The data is returned one record at a time; no averaging is performed. A pointer to a data structure containing all of the data read is returned as store_ptr; the form of the data structure is determined by the sonar system associated with the format of the data being read. A number of different data record types are recognized by MB-System; the kind value indicates which type of record has been read. Additional data is returned if the data record is survey data (navigation, bathymetry, amplitude, and sidescan), navigation data (navigation only), or comment data (comment only).</p>
<p>The return values are:</p>
<ul>
<li>store_ptr: pointer to complete data structure</li>
<li>kind: kind of data record read<ul>
<li>1 survey data</li>
<li>2 comment</li>
<li>3 header</li>
<li>4 calibrate</li>
<li>5 mean sound speed</li>
<li>6 SVP</li>
<li>7 standby</li>
<li>8 nav source</li>
<li>9 parameter</li>
<li>10 start</li>
<li>11 stop</li>
<li>12 nav</li>
<li>13 run parameter</li>
<li>14 clock</li>
<li>15 tide</li>
<li>16 height</li>
<li>17 heading</li>
<li>18 attitude</li>
<li>19 ssv</li>
<li>20 angle</li>
<li>21 event</li>
<li>22 history</li>
<li>23 summary</li>
<li>24 processing parameters</li>
<li>25 sensor parameters</li>
<li>26 navigation error</li>
<li>27 uninterpretable line</li>
</ul>
</li>
<li>time_i: time of current ping<ul>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
</ul>
</li>
<li>time_d: time of current ping in seconds</li>
<li>since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>distance: distance along shiptrack since last ping in km</li>
<li>altitude: altitude of sonar above seafloor in m</li>
<li>sonardepth: depth of sonar in m</li>
<li>nbath: number of bathymetry values</li>
<li>namp: number of amplitude values</li>
<li>nss: number of sidescan values</li>
<li>beamflag: array of bathymetry flags</li>
<li>bath: array of bathymetry values in meters</li>
<li>amp: array of amplitude values in unknown units</li>
<li>bathacrosstrack: array of of acrosstrack distances in meters corresponding to bathymetry</li>
<li>bathalongtrack: array of of alongtrack distances in meters corresponding to bathymetry</li>
<li>ss: array of sidescan values in unknown units</li>
<li>ssacrosstrack: array of of acrosstrack distances in meters corresponding to sidescan</li>
<li>ssacrosstrack: array of of alongtrack distances in meters corresponding to sidescan</li>
<li>comment: comment string</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about read fail- ures.</p>
<h3>mb_put_all()</h3>
<pre class="fragment">int mb_put_all(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int usevalues,
     int kind,
     int time_i[7],
     double time_d,
     double navlon,
     double navlat,
     double speed,
     double heading,
     int nbath,
     int namp,
     int nss,
     char *beamflag,
     double *bath,
     double *amp,
     double *bathacrosstrack,
     double *bathalongtrack,
     double *ss,
     double *ssacrosstrack,
     double *ssalongtrack,
     char *comment,
     int *error);
</pre><p> The function mb_put_all writes sonar data to the file listed in the MBIO descriptor pointed to by MBIO_ptr. The verbose value controls the standard error output verbosity of the function. A pointer to a data structure containing all of the data read is passed as store_ptr; the form of the data structure is determined by the sonar system associated with the format of the data being written. Additional data is passed if the data record is survey data (navigation, bathymetry, amplitude, and sidescan), navigation data (navigation only), or comment data (com- ment only). If the usevalues flag is set to 1, then the passed values will be inserted in the data structure pointed to by store_ptr before the data is written. If the usevalues flag is set to 0, the data structure pointed to by store_ptr will be written without modification.</p>
<p>The values to be output are:</p>
<ul>
<li>store_ptr: pointer to complete data structure</li>
<li>usevalues: flag controlling use of data passed by value<ul>
<li>0 do not insert into data structure before writing the data</li>
<li>1 insert into data structure before writing the data</li>
</ul>
</li>
<li>kind: kind of data record to be written<ul>
<li>1 survey data</li>
<li>2 comment</li>
<li>3 header</li>
<li>4 calibrate</li>
<li>5 mean sound speed</li>
<li>6 SVP</li>
<li>7 standby</li>
<li>8 nav source</li>
<li>9 parameter</li>
<li>10 start</li>
<li>11 stop</li>
<li>12 nav</li>
<li>13 run parameter</li>
<li>14 clock</li>
<li>15 tide</li>
<li>16 height</li>
<li>17 heading</li>
<li>18 attitude</li>
<li>19 ssv</li>
<li>20 angle</li>
<li>21 event</li>
<li>22 history</li>
<li>23 summary</li>
<li>24 processing parameters</li>
<li>25 sensor parameters</li>
<li>26 navigation error</li>
<li>27 uninterpretable line</li>
</ul>
</li>
<li>time_i: time of current ping (used if time_i[0] != 0)</li>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00 (used if time_i[0] = 0)</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>nbath: number of bathymetry values</li>
<li>namp: number of amplitude values</li>
<li>nss: number of sidescan values</li>
<li>beamflag: array of bathymetry flags</li>
<li>bath: array of bathymetry values in meters</li>
<li>amp: array of amplitude values in unknown units</li>
<li>bathacrosstrack: array of of acrosstrack distances in meters corresponding to bathymetry</li>
<li>bathalongtrack: array of of alongtrack distances in meters corresponding to bathymetry</li>
<li>ss: array of sidescan values in unknown units</li>
<li>ssacrosstrack: array of of acrosstrack distances in meters corresponding to sidescan</li>
<li>ssacrosstrack: array of of alongtrack distances in meters corresponding to sidescan</li>
<li>comment: comment string</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about write failures.</p>
<h3>mb_put_comment()</h3>
<pre class="fragment">int mb_put_comment(
     int verbose,
     char *mbio_ptr,
     char *comment,
     int *error);
</pre><p> The function mb_put_comment writes a comment to the file listed in the MBIO descriptor pointed to by MBIO_ptr. The verbose value controls the standard error output verbosity of the function. The data is in the form of a null terminated string. The maximum length of comments varies with different data formats. In general individual comments should be less than 80 characters long to insure compatibility with all formats. The values to be output are:</p>
<ul>
<li>comment: comment string</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about write failures.</p>
<h3>mb_extract()</h3>
<pre class="fragment">int mb_extract(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int *kind,
     int time_i[7],
     double *time_d,
     double *navlon,
     double *navlat,
     double *speed,
     double *heading,
     int *nbath,
     int *namp,
     int *nss,
     char *beamflag,
     double *bath,
     double *amp,
     double *bathacrosstrack,
     double *bathalongtrack,
     double *ss,
     double *ssacrosstrack,
     double *ssalongtrack,
     char *comment,
     int *error);
</pre><p> The function mb_extract extracts sonar data from the structure pointed to by *store_ptr according to the MBIO descriptor pointed to by mbio_ptr. The verbose value controls the standard error output ver- bosity of the function. The form of the data structure is determined by the sonar system associated with the format of the data being read. A number of different data record types are recognized by MB-System; the kind value indicates which type of record is stored in *store_ptr. Additional data is returned if the data record is survey data (naviga- tion, bathymetry, amplitude, and sidescan), navigation data (navigation only), or comment data (comment only).</p>
<p>The return values are:</p>
<ul>
<li>kind: kind of data record read<ul>
<li>1 survey data</li>
<li>2 comment</li>
<li>12 navigation</li>
</ul>
</li>
<li>time_i: time of current ping<ul>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
</ul>
</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>distance: distance along shiptrack since last ping in km</li>
<li>altitude: altitude of sonar above seafloor in m</li>
<li>sonardepth: depth of sonar in m</li>
<li>nbath: number of bathymetry values</li>
<li>namp: number of amplitude values</li>
<li>nss: number of sidescan values</li>
<li>beamflag: array of bathymetry flags</li>
<li>bath: array of bathymetry values in meters</li>
<li>amp: array of amplitude values in unknown units</li>
<li>bathacrosstrack: array of of acrosstrack distances in meters corresponding to bathymetry</li>
<li>bathalongtrack: array of of alongtrack distances in meters corresponding to bathymetry</li>
<li>ss: array of sidescan values in unknown units</li>
<li>ssacrosstrack: array of of acrosstrack distances in meters corresponding to sidescan</li>
<li>ssacrosstrack: array of of alongtrack distances in meters corresponding to sidescan</li>
<li>comment: comment string</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about extract failures.</p>
<h3>mb_insert()</h3>
<pre class="fragment">int mb_insert(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int kind,
     int time_i[7],
     double time_d,
     double navlon,
     double navlat,
     double speed,
     double heading,
     int nbath,
     int namp,
     int nss,
     char *beamflag,
     double *bath,
     double *amp,
     double *bathacrosstrack,
     double *bathalongtrack,
     double *ss,
     double *ssacrosstrack,
     double *ssalongtrack,
     char *comment,
     int *error);
</pre><p> The function mb_insert inserts sonar data into the structure pointed to by *store_ptr according to the MBIO descriptor pointed to by mbio_ptr. The verbose value controls the standard error output verbosity of the function. The form of the data structure is determined by the sonar system associated with the format of the data being read. A number of different data record types are recognized by MB-System; the kind value indicates which type of record is to be stored in *store_ptr. Data will be inserted only if the data record is survey data (navigation, bathymetry, amplitude, and sidescan), navigation data (navigation only), or comment data (comment only). <br  />
</p>
<p>The values to be inserted are:</p>
<ul>
<li>kind: kind of data record inserted<ul>
<li>1 survey data</li>
<li>2 comment</li>
<li>12 navigation</li>
</ul>
</li>
<li>time_i: time of current ping<ul>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
</ul>
</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>distance: distance along shiptrack since last ping in km</li>
<li>altitude: altitude of sonar above seafloor in m</li>
<li>sonardepth: depth of sonar in m</li>
<li>nbath: number of bathymetry values</li>
<li>namp: number of amplitude values</li>
<li>nss: number of sidescan values</li>
<li>beamflag: array of bathymetry flags</li>
<li>bath: array of bathymetry values in meters</li>
<li>amp: array of amplitude values in unknown units</li>
<li>bathacrosstrack: array of of acrosstrack distances in meters corresponding to bathymetry</li>
<li>bathalongtrack: array of of alongtrack distances in meters corresponding to bathymetry</li>
<li>ss: array of sidescan values in unknown units</li>
<li>ssacrosstrack: array of of acrosstrack distances in meters corresponding to sidescan</li>
<li>ssacrosstrack: array of of alongtrack distances in meters corresponding to sidescan</li>
<li>comment: comment string</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about insert failures.</p>
<h3>mb_extract_nav()</h3>
<pre class="fragment">int mb_extract_nav(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int *kind,
     int time_i[7],
     double *time\_d,
     double *navlon,
     double *navlat,
     double *speed,
     double *heading,
     double *draft,
     double *roll,
     double *pitch,
     double *heave,
     int *error);
</pre><p> The function mb_extract_nav extracts navigation data from the structure pointed to by *store_ptr according to the MBIO descriptor pointed to by mbio_ptr. The verbose value controls the standard error output ver- bosity of the function. The form of the data structure is determined by the sonar system associated with the format of the data being read. A number of different data record types are recognized by MB-System; the kind value indicates which type of record is stored in *store_ptr. Navigation data is returned if the data record is survey data (naviga- tion, bathymetry, amplitude, and sidescan) or navigation data (naviga- tion only).</p>
<p>The return values are:</p>
<ul>
<li>kind: kind of data record read<ul>
<li>1 survey data</li>
<li>12 navigation</li>
</ul>
</li>
<li>time_i: time of current ping<ul>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
</ul>
</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>draft: sonar depth in meters</li>
<li>roll: sonar roll in degrees</li>
<li>pitch: sonar pitch in degrees</li>
<li>heave: sonar heave in meters</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about extract failures.</p>
<h3>mb_insert_nav()</h3>
<pre class="fragment">int mb_insert_nav(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int time_i[7],
     double time_d,
     double navlon,
     double navlat,
     double speed,
     double heading,
     double draft,
     double roll,
     double pitch,
     double heave,
     int *error);
</pre><p> The function mb_insert_nav inserts navigation data into the structure pointed to by *store_ptr according to the MBIO descriptor pointed to by mbio_ptr. The verbose value controls the standard error output ver- bosity of the function. The form of the data structure is determined by the sonar system associated with the format of the data being read. A number of different data record types are recognized by MB-System; the kind value indicates which type of record is to be stored in *store_ptr. Data will be inserted only if the data record is survey data (navigation, bathymetry, amplitude, and sidescan), or navigation data (navigation only). The values to be inserted are:</p>
<ul>
<li>time_i: time of current ping<ul>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
</ul>
</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>draft: sonar depth in meters</li>
<li>roll: sonar roll in degrees</li>
<li>pitch: sonar pitch in degrees</li>
<li>heave: sonar heave in meters</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about insert failures.</p>
<h3>mb_extract_altitude()</h3>
<pre class="fragment">int mb_extract_altitude(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int *kind,
     double *transducer_depth,
     double *altitude,
     int *error);
</pre><p> The function mb_extract_altitude extracts the sonar transducer depth (transducer_depth) below the sea surface and the the sonar transducer altitude above the seafloor according to the MBIO descriptor pointed to by mbio_ptr. This function is not defined for all data formats. The verbose value controls the standard error output verbosity of the func- tion. The form of the data structure is determined by the sonar system associated with the format of the data being read. A number of differ- ent data record types are recognized by MB-System; the kind value indi- cates which type of record is stored in *store_ptr. These data are returned only if the data record is survey data. These values are use- ful for sidescan processing applications. Both transducer depths and altitudes are reported in meters.</p>
<p>The return values are:</p>
<ul>
<li>kind: kind of data record read (error if not survey data):<ul>
<li>1 survey data</li>
</ul>
</li>
<li>transducer_depth: depth of sonar in meters</li>
<li>altitude: altitude of sonar above seafloor in meters.</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about data extraction failures.</p>
<h3>mb_insert_altitude()</h3>
<pre class="fragment">int mb_insert_altitude(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     double transducer_depth,
     double altitude,
     int *error);
</pre><p> The function mb_insert_altitude inserts sonar depth and altitude data into the structure pointed to by *store_ptr according to the MBIO descriptor pointed to by mbio_ptr. This function is not defined for all data formats. The verbose value controls the standard error output verbosity of the function. The form of the data structure is deter- mined by the sonar system associated with the format of the data being read. A number of different data record types are recognized by MB-Sys- tem. Data will be inserted only if the data record is survey data (navigation, bathymetry, amplitude, and sidescan). The values to be inserted are:</p>
<ul>
<li>transducer_depth: depth of sonar in meters</li>
<li>altitude: altitude of sonar in meters</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about insert failures.</p>
<h3>mb_extract_svp()</h3>
<pre class="fragment">int mb_extract_svp(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int *kind,
     int *nsvp,
     double *depth,
     double *velocity,
     int *error);
</pre><p> The function mb_extract_svp extracts a water sound velocity profile according to the MBIO descriptor pointed to by mbio_ptr. This function is not defined for all data formats. The verbose value controls the standard error output verbosity of the function. The form of the data structure is determined by the sonar system associated with the format of the data being read. A number of different data record types are recognized by MB-System; the kind value indicates which type of record is stored in *store_ptr. These data are returned only if the data record is a sound velocity profile record. These values are useful for calculating bathymetry from travel times and beam angles.</p>
<p>The return values are:</p>
<ul>
<li>kind: kind of data record read (error if not SVP data):<ul>
<li>6 SVP data</li>
</ul>
</li>
<li>nsvp: number of depth and sound speed data in the profile</li>
<li>depth: array of depths in meters</li>
<li>velocity: array of sound speeds in m/sec</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about data extraction failures.</p>
<h3>mb_insert_svp()</h3>
<pre class="fragment">int mb_insert_svp(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int nsvp,
     double *depth,
     double *velocity,
     int *error);
</pre><p> The function mb_insert_svp inserts a water sound velocity profile according to the MBIO descriptor pointed to by mbio_ptr. This function is not defined for all data formats. The verbose value controls the standard error output verbosity of the function. The form of the data structure is determined by the sonar system associated with the format of the data being read. A number of different data record types are recognized by MB-System. These data are inserted only if the data record is a sound velocity profile record. These values are useful for calculating bathymetry from travel times and beam angles. <br  />
</p>
<p>The inserted values are:</p>
<ul>
<li>nsvp: number of depth and sound speed data in the profile</li>
<li>depth: array of depths in meters</li>
<li>velocity: array of sound speeds in m/sec</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about data insertion failures.</p>
<h3>mb_ttimes()</h3>
<pre class="fragment">int mb\_ttimes(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int *kind,
     int *nbeams,
     double *ttimes,
     double    *angles,
     double *angles_forward,
     double *angles_null,
     double *heave,
     double *alongtrack_offset,
     double *draft,
     double *ssv,
     int *error);
</pre><p> The function mb_ttimes extracts travel times and beam angles from a sonar-specific data structure pointed to by store_ptr. These values are used for calculating swath bathymetry. The verbose value controls the standard error output verbosity of the function. The coordinates of the beam angles can be a bit confusing. The angles are returned in "takeoff angle  coordinates" appropriate for raytracing. The array angles contains the angle from vertical and the array angles_forward contains the angle from acrosstrack. This coordinate system is distinct from the roll-pitch coordinates appropriate for correcting roll and pitch values. A description of these relevant coordinate systems is given below. The angles_null array contains the effective sonar array orientation for each beam. The angles_null array may be used to correct beam angles using Snell's law if the ssv is changed. The angles_null values reflect the sonar configuration. For example, some multibeam sonars have a flat transducer array, and so the angles_null array con- sists of nbeams zero values. Other multibeams have circular arrays so that the angles_null values equal the angles values. The along- track_offset array accommodates sonars which report multiple pings in a single survey record; each ping occurs at a different position along the shiptrack, producing alongtrack offsets relative to the navigation for some beam values. The sum of the draft value and the heave array values gives the depth of the sonar for each beam. For hull mounted installations the draft value is generally static but the heave values vary with time. For towed sonars the draft varies with time and the heave values are typically zero. The ssv value gives the water sound velocity at the sonar array.</p>
<p>The return values are:</p>
<ul>
<li>kind: kind of data record read (error if not survey data):<ul>
<li>1 survey data</li>
</ul>
</li>
<li>nbeams: number of beams</li>
<li>ttimes: array of two-way travel times in seconds</li>
<li>angles: array of angles from vertical in degrees</li>
<li>angles_forward: array of angles from acrosstrack in degrees</li>
<li>angles_null: array of sonar array orientation in degrees</li>
<li>heave: array of heave values for each beam in meters</li>
<li>alongtrack_offset:array of alongtrack distance offsets for each beam in meters</li>
<li>draft: draft of sonar in meters</li>
<li>ssv: water sound velocity at sonar in m/seconds</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about data extraction failures.</p>
<h3>mb_detects()</h3>
<pre class="fragment">int mb_detects(
     int verbose,
     void *mbio_ptr,
     void *store_ptr,
     int *kind,
     int *nbeams,
     int *detects,
     int *error);
</pre><p> The function mb_detects extracts beam bottom detect types from a sonar- specific data structure pointed to by store_ptr. These values indicate whether the depth value associated with a particular beam i derived from an amplitude detect (e.g. detects[i] = 1), a phase detect (e.g. detects[i] = 2), or the algorithm is unknown (e.g. detects[i] = 0). The verbose value controls the standard error output verbosity of the func- tion.</p>
<p>The return values are:</p>
<ul>
<li>kind: kind of data record read (error if not survey data):<ul>
<li>1 survey data</li>
</ul>
</li>
<li>nbeams: number of beams</li>
<li>detects: array of nbeams bottom detect algorithm flags<ul>
<li>0 = unknown <br  />
</li>
<li>1 = amplitude detect <br  />
</li>
<li>2 = phase detect</li>
</ul>
</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about data extraction failures. This functionality is available for only a subset of the supported sonars. If the corresponding low level routine is undefined, *error will be set to MB_ERROR_BAD_SYSTEM (14).</p>
<h3>mb_gains()</h3>
<pre class="fragment">int mb_gains(
     int verbose,
     void *mbio_ptr,
     void *store_ptr,
     int *kind,
     double *transmit_gain,
     double *pulse_length,
     double *receive_gain,
     int *error);
</pre><p> The function mb_gains extracts the most basic gain settings from a sonar-specific data structure pointed to by store_ptr. In many cases, sonars have more complicated gain functions, particularly with respect to the receiver TVG function. In those cases, the receive gain returned here refers to the constant gain setting and does not include any TVG parameters. The verbose value controls the standard error output ver- bosity of the function.</p>
<p>The return values are:</p>
<ul>
<li>kind: kind of data record read (error if not survey data):<ul>
<li>1 survey data</li>
</ul>
</li>
<li>transmit_gain: transmit gain (dB)</li>
<li>pulse_length: transmit pulse length (sec)</li>
<li>receive_gain: receive gain (dB)</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about data extraction failures. This functionality is available for only a subset of the supported sonars. If the corresponding low level routine is undefined, *error will be set to MB_ERROR_BAD_SYSTEM (14).</p>
<h3>mb_extract_rawss()</h3>
<pre class="fragment">int mb_extract_rawss(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int *kind,
     int *nrawss,
     double *rawss,
     double *rawssacrosstrack,
     double *rawssalongtrack,
     int *error);
</pre><p> This function has not yet been implemented for any data format. The notion is that since some formats carry both "raw" and "processed" sidescan imagery, there should be functions to extract and insert the "raw" sidescan. Given that the meaning of "raw" sidescan varies greatly among sonars, the processing one might apply to the data will depend on the sonar source. The definition of mb_extract_rawss may well change when we actually implement it.</p>
<h3>mb_insert_rawss()</h3>
<pre class="fragment">int mb\_insert_rawss(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     int nrawss,
     double *rawss,
     double *rawssacrosstrack,
     double *rawssalongtrack,
     int *error);
</pre><p> This function has not yet been implemented for any data format. The notion is that since some formats carry both "raw" and "processed" sidescan imagery, there should be functions to extract and insert the "raw" sidescan. Given that the meaning of "raw" sidescan varies greatly among sonars, the processing one might apply to the data will depend on the sonar source. The definition of mb_insert_rawss may well change when we actually implement it.</p>
<h3>mb_copyrecord()</h3>
<pre class="fragment">int mb_copyrecord(
     int verbose,
     char *mbio_ptr,
     char *store_ptr,
     char *copy_ptr,
     int *error);
</pre><p> The function mb_copyrecord copies the sonar-specific data structure pointed to by store_ptr into the data structure pointed to by *copy_ptr. The data structures must already have been allocated.</p>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about data copy failures.</p>
<h2>Level 3 Functions</h2>
<h3>mb_buffer_init()</h3>
<pre class="fragment">int mb_buffer_init(
     int verbose,
     char **buff_ptr,
     int *error);
</pre><p> The function mb_buffer_init initializes the data structures required for buffered i/0. A pointer to the buffer data structure is returned as *buff_ptr. The verbose value controls the standard error output ver- bosity of the function.</p>
<p>The return values are:</p>
<ul>
<li>*buff_ptr: pointer to buffer structure</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about buffer initialization failures.</p>
<h3>mb_buffer_close()</h3>
<pre class="fragment">int mb_buffer_close(
     int verbose,
     char **buff_ptr,
     char *mbio_ptr,
     int *error);
</pre><p> The function mb_buffer_close releases all memory allocated for buffered i/0, including the structure pointed to by *buff_ptr. The verbose value controls the standard error output verbosity of the function.</p>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about buffer deallocation failures.</p>
<h3>mb_buffer_load()</h3>
<pre class="fragment">int mb_buffer_load(
     int verbose,
     char *buff_ptr,char *mbio_ptr,
     int nwant,
     int *nload,
     int *nbuff,
     int *error);
</pre><p> The function mb_buffer_load loads data into the buffer pointed to by buff_ptr from the input file initialized in the MBIO descriptor pointed to by mbio_ptr. The verbose value controls the standard error output verbosity of the function.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>nwant: The number of data records desired in the buffer.</li>
</ul>
<p>The returned values are:</p>
<ul>
<li>nload: The number of data records loaded into the buffer.</li>
<li>nbuff: The total number of data records in the buffer after loading.</li>
<li>error: error value</li>
</ul>
<p>The buffer may already contain data records when the mb_buffer_load call is made; if the number of previously loaded records is less than nwant, the function will attempt to read and load records until a total of nwant records are loaded. The nload value is the number of data records loaded during the current function call, and the nbuff value is the number of data records in the buffer at the completion of the mb_buffer_load call. A status value indicating success or failure is returned; the error value argument error passes more detailed information about buffer deallocation failures.</p>
<h3>mb_buffer_dump()</h3>
<pre class="fragment">int mb\_buffer_dump(
     int verbose,
     char *buff_ptr,
     char *mbio_ptr,
     char *ombio_ptr,
     int nhold,
     int *ndump,
     int *nbuff,
     int *error);
</pre><p> The function mb_buffer_dump dumps data from the buffer pointed to by *buff_ptr into the output file initialized in the MBIO descriptor pointed to by ombio_ptr. The data in the buffer were read from the input file initialized in the MBIO descriptor pointed to by mbio_ptr. The verbose value controls the standard error output verbosity of the function.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>nhold: The number of data records desired to be held in the buffer.</li>
</ul>
<p>The returned values are:</p>
<ul>
<li>nload: The number of data records dumped from the buffer.</li>
<li>nbuff: The total number of data records in the buffer after dumping.</li>
<li>error: error value</li>
</ul>
<p>If the number of loaded records is more than nhold, the function will attempt to write out records from the beginning of the buffer until nhold records are left in the buffer. The ndump value is the number of data records dumped during the current function call, and the nbuff value is the number of data records in the buffer at the completion of the mb_buffer_dump call. A status value indicating success or failure is returned; the error value argument error passes more detailed information about buffer deallocation failures.</p>
<h3>mb_buffer_clear()</h3>
<pre class="fragment">int mb_buffer_clear(
     int verbose,
     char *buff_ptr,
     char *mbio_ptr,
     int nhold,
     int *ndump,
     int *nbuff,
     int *error);
</pre><p> The function mb_buffer_clear removes data from the buffer pointed to by *buff_ptr without writing those data records to an output file. An MBIO descriptor pointed to by mbio_ptr is still required, and generally rep- resents the MBIO descriptor used to read and load the data originally. The verbose value controls the standard error output verbosity of the function.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>nwant: The number of data records desired to be held in the buffer.</li>
</ul>
<p>The returned values are:</p>
<ul>
<li>nload: The number of data records cleared from the buffer.</li>
<li>nbuff: The total number of data records in the buffer after dumping.</li>
<li>error: error value</li>
</ul>
<p>If the number of loaded records is more than nhold, the function will attempt to clear out records from the beginning of the buffer until nhold records are left in the buffer. The ndump value is the number of data records cleared during the current function call, and the nbuff value is the number of data records in the buffer at the completion of the mb_buffer_dump call. A status value indicating success or failure is returned; the error value argument error passes more detailed information about buffer deallocation failures.</p>
<h3>mb_buffer_info()</h3>
<pre class="fragment">int mb_buffer_info(
     int verbose,
     char *buff_ptr,
     char *mbio_ptr,
     int id,
     int *system,
     int *kind,
     int *error);
</pre><p> The function mb_buffer_clear removes data from the buffer pointed to by *buff_ptr without writing those data records to an output file. An MBIO descriptor pointed to by mbio_ptr is still required, and generally rep- resents the MBIO descriptor used to read and load the data originally. The verbose value controls the standard error output verbosity of the function.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>nwant: The number of data records desired to be held in the buffer.</li>
</ul>
<p>The returned values are:</p>
<ul>
<li>nload: The number of data records cleared from the buffer.</li>
<li>nbuff: The total number of data records in the buffer after dumping.</li>
<li>error: error value</li>
</ul>
<p>If the number of loaded records is more than nhold, the function will attempt to clear out records from the beginning of the buffer until nhold records are left in the buffer. The ndump value is the number of data records cleared during the current function call, and the nbuff value is the number of data records in the buffer at the completion of the mb_buffer_dump call. A status value indicating success or failure is returned; the error value argument error passes more detailed information about buffer deallocation failures.</p>
<h3>mb_buffer_get_next_data()</h3>
<pre class="fragment">int mb_buffer_get_next_data(
     int verbose,
     char *buff_ptr,
     char *mbio_ptr,
     int start,
     int *id,
     int time_i[7],
     double *time_d,
     double *navlon,
     double *navlat,
     double *speed,
     double *heading,
     int *nbath,
     int *namp,
     int *nss,
     char *beamflag,
     double *bath,
     double *amp,
     double *bathacrosstrack,
     double *bathalongtrack,
     double *ss,
     double *ssacrosstrack,
     double *ssalongtrack,
     int *error);
</pre><p> The function mb_buffer_get_next_data searches for the next survey data record in the buffer, beginning at buffer index start. Since buffer indexes begin at 0, the first call to mb_buffer_get_next_data should have start = 0. If a survey data record is found at or beyond start, mb_buffer_get_next_data returns the buffer index of that record in id. Data is also returned in the forms of bathymetry, amplitude, and sides- can survey data. No comments or other non-survey data records are returned. The verbose value controls the standard error output ver- bosity of the function.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>start: The buffer index at which to start searching for a survey data record.</li>
</ul>
<p>The returned values are:</p>
<ul>
<li>id: The buffer index of the first survey data record at or after start.</li>
<li>time_i: time of current ping<ul>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
</ul>
</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>nbath: number of bathymetry values</li>
<li>namp: number of amplitude values</li>
<li>nss: number of sidescan values beamflag: array of bathymetry flags</li>
<li>bath: array of bathymetry values in meters</li>
<li>amp: array of amplitude values in unknown units</li>
<li>bathacrosstrack: array of of acrosstrack distances in meters corresponding to bathymetry</li>
<li>bathalongtrack: array of of alongtrack distances in meters corresponding to bathymetry</li>
<li>ss: array of sidescan values in unknown units</li>
<li>ssacrosstrack: array of of acrosstrack distances in meters corresponding to sidescan</li>
<li>ssacrosstrack: array of of alongtrack distances in meters corresponding to sidescan</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures. The most common error occurs when no more survey data records remain to be found in the buffer; in this case, error = -14.</p>
<h3>mb_buffer_extract()</h3>
<pre class="fragment">int mb_buffer_extract(
     int verbose,
     char *buff_ptr,
     char *mbio_ptr,
     int id,
     int *kind,
     int time_i[7],
     double *time_d,
     double *navlon,
     double *navlat,
     double *speed,
     double *heading,
     int *nbath,
     int *namp,
     int *nss,
     char *beamflag,
     double *bath,
     double *amp,
     double *bathacrosstrack,
     double *bathalongtrack,
     double *ss,
     double *ssacrosstrack,
     double *ssalongtrack,
     char *comment,
     int *error);
</pre><p> The function mb_buffer_extract extracts and returns a subset of the data in a buffer record. The verbose value controls the standard error output verbosity of the function. The buffer record is specified with the buffer index id. The data is either in the form of bathymetry, amplitude, and sidescan survey data or a comment string.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>id: The buffer index of the data record to extract.</li>
</ul>
<p>The returned values are:</p>
<ul>
<li>kind: kind of data record extracted<ul>
<li>1 survey data</li>
<li>2 comment</li>
<li>&gt;=3 other data that cannot be passed by mb_buffer_extract</li>
</ul>
</li>
<li>time_i: time of current ping</li>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>nbath: number of bathymetry values</li>
<li>namp: number of amplitude values</li>
<li>nss: number of sidescan values</li>
<li>beamflag: array of bathymetry flags</li>
<li>bath: array of bathymetry values in meters</li>
<li>amp: array of amplitude values in unknown units</li>
<li>bathacrosstrack: array of of acrosstrack distances in meters corresponding to bathymetry</li>
<li>bathalongtrack: array of of alongtrack distances in meters corresponding to bathymetry</li>
<li>ss: array of sidescan values in unknown units</li>
<li>ssacrosstrack: array of of acrosstrack distances in meters corresponding to sidescan</li>
<li>ssacrosstrack: array of of alongtrack distances in meters corresponding to sidescan</li>
<li>comment: comment string</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about extract failures.</p>
<h3>mb_buffer_insert()</h3>
<pre class="fragment">int mb_buffer_insert(
     int verbose,
     char *buff_ptr,
     char *mbio_ptr,
     int id,
     int time_i[7],
     double time_d,
     double navlon,
     double navlat,
     double speed,
     double heading,
     int nbath,
     int namp,
     int nss,
     char *beamflag,
     double *bath,
     double *amp,
     double *bathacrosstrack,
     double *bathalongtrack,
     double *ss,
     double *ssacrosstrack,
     double *ssalongtrack,
     char *comment,
     int *error);
</pre><p> The function mb_buffer_insert inserts data into a buffer record, replacing a subset of the original values. The verbose value controls the standard error output verbosity of the function. The buffer record is specified with the buffer index id. The data is either in the form of bathymetry, amplitude, and sidescan survey data or a comment string.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>id: The buffer index of the data record to insert.</li>
</ul>
<p>The returned values are:</p>
<ul>
<li>kind: kind of data record inserted<ul>
<li>1 survey data</li>
<li>2 comment</li>
<li>&gt;=3 other data that cannot be passed by mb_buffer_insert</li>
</ul>
</li>
<li>time_i: time of current ping<ul>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
</ul>
</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>nbath: number of bathymetry values</li>
<li>namp: number of amplitude values</li>
<li>nss: number of sidescan values</li>
<li>beamflag: array of bathymetry flags</li>
<li>bath: array of bathymetry values in meters</li>
<li>amp: array of amplitude values in unknown units</li>
<li>bathacrosstrack: array of of acrosstrack distances in meters corresponding to bathymetry</li>
<li>bathalongtrack: array of of alongtrack distances in meters corresponding to bathymetry</li>
<li>ss: array of sidescan values in unknown units</li>
<li>ssacrosstrack: array of of acrosstrack distances in meters corresponding to sidescan</li>
<li>ssacrosstrack: array of of alongtrack distances in meters corresponding to sidescan</li>
<li>comment: comment string</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about insert failures.</p>
<h3>mb_buffer_get_next_nav()</h3>
<pre class="fragment">int mb_buffer_get_next_nav(
     int verbose,
     char *buff_ptr,
     char *mbio_ptr,
     int start,
     int *id,
     int time_i[7],
     double *time_d,
     double *navlon,
     double *navlat,
     double *speed,
     double *heading,
     double *draft,
     double *roll,
     double *pitch,
     double *heave,
     int *error);
</pre><p> The function mb_buffer_get_next_nav searches for the next survey data record in the buffer, beginning at buffer index start. Since buffer indexes begin at 0, the first call to mb_buffer_get_next_nav should have start = 0. If a survey data record is found at or beyond start, mb_buffer_get_next_nav returns the buffer index of that record in id. Navigation and vertical reference sensor data is also returned. No com- ments or other non-survey data records are returned. The verbose value controls the standard error output verbosity of the function.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>start: The buffer index at which to start searching for a survey data record.</li>
</ul>
<p>The returned values are:</p>
<ul>
<li>id: The buffer index of the first survey data record at or after start.</li>
<li>time_i: time of current ping</li>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>roll: ship roll in degrees</li>
<li>pitch: ship pitch in degrees</li>
<li>heave: ship heave in meters</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures. The most common error occurs when no more survey data records remain to be found in the buffer; in this case, error = -14.</p>
<h3>mb_buffer_extract_nav()</h3>
<pre class="fragment">int mb_buffer_extract_nav(
     int verbose,
     char *buff_ptr,
     char *mbio_ptr,
     int id,
     int *kind,
     int time_i[7],
     double *time_d,
     double *navlon,
     double *navlat,
     double *speed,
     double *heading,
     double *draft,
     double *roll,
     double *pitch,
     double *heave,
     int *error);
</pre><p> The function mb_buffer_extract_nav extracts and returns a subset of the data in a buffer record. The verbose value controls the standard error output verbosity of the function. The buffer record is specified with the buffer index id. The data returned consists of navigation and ver- tical reference sensor data.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>id: The buffer index of the data record to extract.</li>
</ul>
<p>The returned values are:</p>
<ul>
<li>kind: kind of data record extracted</li>
<li>1 survey data</li>
<li>2 comment</li>
<li>&gt;=3 other data that cannot be passed by mb_buffer_extract_nav</li>
<li>time_i: time of current ping<ul>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
</ul>
</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>roll: ship roll in degrees</li>
<li>pitch: ship pitch in degrees</li>
<li>heave: ship heave in meters</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about extract failures.</p>
<h3>mb_buffer_insert_nav()</h3>
<pre class="fragment">int mb_buffer_insert_nav(
     int verbose,
     char *buff_ptr,
     char *mbio_ptr,
     int id,
     int time_i[7],
     double time_d,
     double navlon,
     double navlat,
     double speed,
     double heading,
     double draft,
     double roll,
     double pitch,
     double heave,
     int *error);
</pre><p> The function mb_buffer_insert_nav inserts navigation and vertical ref- erence sensor data into a buffer record, replacing a subset of the original values. The verbose value controls the standard error output verbosity of the function. The buffer record is specified with the buffer index id.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>id: The buffer index of the data record to insert.</li>
</ul>
<p>The returned values are:</p>
<ul>
<li>kind: kind of data record inserted</li>
<li>1 survey data</li>
<li>2 comment</li>
<li>&gt;=3 other data that cannot be passed by mb_buffer_insert_nav</li>
<li>time_i: time of current ping<ul>
<li>time_i[0]: year</li>
<li>time_i[1]: month</li>
<li>time_i[2]: day</li>
<li>time_i[3]: hour</li>
<li>time_i[4]: minute</li>
<li>time_i[5]: second</li>
<li>time_i[6]: microsecond</li>
</ul>
</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>navlon: longitude</li>
<li>navlat: latitude</li>
<li>speed: ship speed in km/s</li>
<li>heading: ship heading in degrees</li>
<li>roll: ship roll in degrees</li>
<li>pitch: ship pitch in degrees</li>
<li>heave: ship heave in meters</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about insert failures.</p>
<h3>mb_buffer_get_ptr()</h3>
<pre class="fragment">int mb_buffer_get_ptr(
     int verbose,
     char *buff_ptr,
     char *mbio_ptr,
     int id,
     char **store_ptr,
     int *error);
</pre><p> The function mb_buffer_get_ptr returns a pointer to the data structure in a buffer record. The verbose value controls the standard error out- put verbosity of the function. The buffer record is specified with the buffer index id. The data returned consists of a pointer to the data structure stored in the specified buffer record.</p>
<p>The input control parameters have the following significance:</p>
<ul>
<li>id: The buffer index of the data record to locate.</li>
</ul>
<p>The return values are:</p>
<ul>
<li>*store_ptr: pointer to data in specified buffer record</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about buffer failures.</p>
<h2>Miscellaneous Functions</h2>
<h3>mb_defaults()</h3>
<pre class="fragment">int mb_defaults(
     int verbose,
     int *format,
     int *pings,
     int *lonflip,
     double bounds[4],
     int *btime_i,
     int *etime_i,
     double *speedmin,
     double *timegap);
</pre><p> The function mb_defaults provides default values of control parameters used by some of the MBIO functions. The verbose value controls the standard error output verbosity of the function. The other parameters are set by the function; the meaning of these parameters is discussed in the listings of the functions mb_read_init and mb_write_init. If an .mbio_defaults file exists in the user's home directory, the lonflip and timegap defaults are read from this file. Otherwise, the values are set as:</p>
<ul>
<li>*lonflip = 0</li>
<li>*timegap = 1</li>
</ul>
<p>The other values are simply set as:</p>
<ul>
<li>*format = 0</li>
<li>*pings = 1</li>
<li>bounds[0] = -360.</li>
<li>bounds[1] = 360.</li>
<li>bounds[2] = -90.</li>
<li>bounds[3] = 90.</li>
<li>btime_i[0] = 1962;</li>
<li>btime_i[1] = 2;</li>
<li>btime_i[2] = 21;</li>
<li>btime_i[3] = 10;</li>
<li>btime_i[4] = 30;</li>
<li>btime_i[5] = 0;</li>
<li>btime_i[6] = 0;</li>
<li>etime_i[0] = 2062;</li>
<li>etime_i[1] = 2;</li>
<li>etime_i[2] = 21;</li>
<li>etime_i[3] = 10;</li>
<li>etime_i[4] = 30;</li>
<li>etime_i[5] = 0;</li>
<li>etime_i[6] = 0;</li>
<li>*speedmin = 0.0</li>
</ul>
<p>A status value is returned to indicate success or failure.</p>
<h3>mb_env()</h3>
<pre class="fragment">int mb_env(
     int verbose,
     char *psdisplay,
     char *imgdisplay,
     char *mbproject);
</pre><p> The function mb_env provides default values of Postscript and image display programs invoked by some MB-System programs and macros, and a default value for a working project name that will be used by future applications. The verbose value controls the standard error output ver- bosity of the function. If an .mbio_defaults file exists in the user's home directory, the *psdisplay, *imgdisplay, *mbproject defaults are read from this file. Otherwise, the values are set as:</p>
<ul>
<li>psdisplay = "xpsview" (IRIX OS)<ul>
<li>"pageview" (Solaris OS)</li>
<li>"gv" (other OS)</li>
<li>"ghostview" (other OS)</li>
</ul>
</li>
<li>imgdisplay = "gimp" (Linux OS)<ul>
<li>"xv" (other than Linux OS)</li>
</ul>
</li>
<li>mbproject = "none"</li>
</ul>
<h3>mb_format()</h3>
<pre class="fragment">int mb_format(
     int verbose,
     int *format,
     int *error);
</pre><p> Given the format identifier format, mb_format checks if the format is valid. If the format id corresponds to a value used in previous (&lt;4.00) versions of MB-System, then the format value will be aliased to the current corresponding value.</p>
<p>The return values are:</p>
<ul>
<li>format: MBIO format id</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_format_register()</h3>
<pre class="fragment">int mb_format_register(
     int verbose,
     int *format,
     char *mbio_ptr,
     int *error);
</pre><p> The function mb_format_register is called by mb_read_init and mb_write_init and serves to load format specific parameters and func- tion parameters into the MBIO control structure pointed to by *error. The format id *format is first checked for validity. In some cases, formerly valid but now obsolete format id values are mapped to current values.</p>
<p>The input values are:</p>
<ul>
<li>*format: MBIO format id</li>
<li>*mbio_ptr: pointer to data in specified buffer record</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_format_info()</h3>
<pre class="fragment">int mb_format_info(
     int verbose,
     int *format,
     int *system,
     int *beams_bath_max,
     int *beams_amp_max,
     int *pixels_ss_max,
     char *format_name,
     char *system_name,
     char *format_description,
     int *numfile,
     int *filetype,
     int *variable_beams,
     int *traveltime,
     int *beam_flagging,
     int *nav_source,
     int *heading_source,
     int *vru_source,
     double *beamwidth_xtrack,
     double *beamwidth_ltrack,
     int *error);
</pre><p> The function mb_format_info returns a variety of data format specific parameters. The format id *format is first checked for validity. In some cases, formerly valid but now obsolete format id values are mapped to current values.</p>
<p>The input values are: *format: MBIO format id</p>
<p>The return values are:</p>
<ul>
<li>*format: MBIO format id</li>
<li>*system: MBIO sonar system id</li>
<li>*beams_bath_max: maximum number of bathymetry beams</li>
<li>*beams_amp_max: maximum number of amplitude beams</li>
<li>*pixels_ss_max: maximum number of sidescan pixels</li>
<li>*format_name: MBIO format name</li>
<li>*system_name: MBIO sonar system name</li>
<li>*format_description: MBIO format description</li>
<li>*numfile: number of parallel data files used in format</li>
<li>*filetype: type of data files</li>
<li>*variable_beams: number of beams can vary [boolean]</li>
<li>*traveltime: travel time data available [boolean]</li>
<li>*beam_flagging: beam flagging supported [boolean]</li>
<li>*nav_source: kind of data records containing navigation</li>
<li>*heading_source: kind of data records containing heading</li>
<li>*vru_source: kind of data records containing attitude</li>
<li>*beamwidth_xtrack: typical athwartships beam width [degrees]</li>
<li>*beamwidth_ltrack: typical alongtrack beam width [degrees]</li>
<li>*error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_format_system()</h3>
<pre class="fragment">int mb_format_system(
     int verbose,
     int *format,
     int *system,
     int *error);
</pre><p> The function mb_format_system returns the MBIO sonar system id. The format id *format is first checked for validity. In some cases, for- merly valid but now oattintbsolete format id values are mapped to cur- rent values. The input values are:</p>
<ul>
<li>*format: MBIO format id</li>
</ul>
<p>The return values are:</p>
<ul>
<li>*format: MBIO format id</li>
<li>*system: MBIO sonar system id</li>
<li>*error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_format_description()</h3>
<pre class="fragment">int mb_format_description(
     int verbose,
     int *format,
     char *description,
     int *error);
</pre><p> The function mb_format_description returns a short description of the format in the string *description. The format id *format is first checked for validity. In some cases, formerly valid but now obsolete format id values are mapped to current values. The input values are:</p>
<ul>
<li>*format: MBIO format id</li>
</ul>
<p>The return values are:</p>
<ul>
<li>*format: MBIO format id</li>
<li>*format_description: MBIO format description</li>
<li>*error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_format_dimensions()</h3>
<pre class="fragment">int mb_format_dimensions(
     int verbose,
     int *format,
     int *beams_bath_max,
     int *beams_amp_max,
     int *pixels_ss_max,
     int *error);
</pre><p> The function mb_format_dimensions returns the maximum numbers of beams and pixels associated with a particular data format. The format id *format is first checked for validity. In some cases, formerly valid but now obsolete format id values are mapped to current values.</p>
<p>The input values are:</p>
<ul>
<li>*format: MBIO format id</li>
</ul>
<p>The return values are:</p>
<ul>
<li>*format: MBIO format id</li>
<li>*beams_bath_max: maximum number of bathymetry beams</li>
<li>*beams_amp_max: maximum number of amplitude beams</li>
<li>*pixels_ss_max: maximum number of sidescan pixels</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_format_flags()</h3>
<pre class="fragment">int mb_format_flags(
     int verbose,
     int *format,
     int *variable_beams,
     int *traveltime,
     int *beam_flagging,
     int *error);
</pre><p> The function mb_format_flags returns flags indicating certain charac- teristics of the specified data format. The format id *format is first checked for validity. In some cases, formerly valid but now obsolete format id values are mapped to current values.</p>
<p>The input values are:</p>
<ul>
<li>*format: MBIO format id</li>
</ul>
<p>The return values are:</p>
<ul>
<li>*format: MBIO format id</li>
<li>*variable_beams: number of beams can vary [boolean]</li>
<li>*traveltime: travel time data available [boolean]</li>
<li>*beam_flagging: beam flagging supported [boolean]</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_format_source()</h3>
<pre class="fragment">int mb_format_source(
     int verbose,
     int *format,
     int *nav_source,
     int *heading_source,
     int *vru_source,
     int *error);
</pre><p> The function mb_format_source returns flags indicating what kinds of data records contain navigation, heading, and attitude values in the specified data format. The format id *format is first checked for validity. In some cases, formerly valid but now obsolete format id val- ues are mapped to current values.</p>
<p>The input values are:</p>
<ul>
<li>*format: MBIO format id</li>
</ul>
<p>The return values are:</p>
<ul>
<li>*format: MBIO format id</li>
<li>*nav_source: kind of data records containing navigation</li>
<li>*heading_source: kind of data records containing heading</li>
<li>*vru_source: kind of data records containing attitude</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_format_beamwidth()</h3>
<pre class="fragment">int mb_format_beamwidth(
     int verbose,
     int *format,
     double *beamwidth_xtrack,
     double *beamwidth_ltrack,
     int *error);
</pre><p> The function mb_format_beamwidth returns typical, upper bound values for athwartships and alongtrack beam widths. The format id *format is first checked for validity. In some cases, formerly valid but now obso- lete format id values are mapped to current values.</p>
<p>The input values are:</p>
<ul>
<li>*format: MBIO format id</li>
</ul>
<p>The return values are:</p>
<ul>
<li>*format: MBIO format id</li>
<li>*beamwidth_xtrack: typical athwartships beam width [degrees]</li>
<li>*beamwidth_ltrack: typical alongtrack beam width [degrees]</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_datalist_open()</h3>
<pre class="fragment">int mb_datalist_open(
     int verbose,
     char **datalist,
     char *path,
     int look_processed,
     int *error);
</pre><p> The function mb_datalist_open initializes reading from a datalist tree. The string *path is the path to the top level datalist file to be opened. The value look_processed indicates whether the datalist pars- ing should look for or ignore processed data files (see the mbprocess and mbdatalist manual pages). <br  />
</p>
<p>The input values are:</p>
<ul>
<li>*path: datalist file to be opened</li>
<li>look_processed: processed file behavior<ul>
<li>0 : unset</li>
<li>1 : ignore processed files</li>
<li>2 : return processed files</li>
</ul>
</li>
</ul>
<p>The return values are:</p>
<ul>
<li>**datalist: pointer to datalist structure</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_datalist_read()</h3>
<pre class="fragment">int mb_datalist_read(
     int verbose,
     char *datalist,
     char *path,
     int *format,
     double *weight,
     int *error);
</pre><p> The function mb_datalist_read reads from a datalist tree, attempting to return the path to the next valid swath data file, the corresponding data format id, and a gridding weight (see the mbprocess and mbdatalist manual pages). Information about the datalist tree is embedded in a data structure pointed to by *datalist.</p>
<p>The input values are:</p>
<ul>
<li>*datalist: pointer to datalist structure</li>
</ul>
<p>The return values are:</p>
<ul>
<li>*path: swath data file</li>
<li>*format: MBIO format id</li>
<li>*weight: mbgrid gridding weight</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_datalist_close()</h3>
<pre class="fragment">int mb_datalist_close(
     int verbose,
     char **datalist,
     int *error);
</pre><p> The function mb_datalist_close closes an open datalist tree, and deal- locates the data structure pointed to by *datalist. <br  />
</p>
<p>The input values are:</p>
<ul>
<li>*datalist: pointer to datalist structure</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_alloc()</h3>
<pre class="fragment">int mb_alloc(
     int verbose,
     char *mbio_ptr,
     char **store_ptr,
     int *error);
</pre><p> The function mb_alloc allocates a data structure for internal storage of swath sonar data and returns a pointer to this structure in *store_ptr. The data structure is specific to the data format identi- fied in the MBIO data structure pointed to by *mbio_ptr. <br  />
</p>
<p>The input values are:</p>
<ul>
<li>*mbio_ptr: pointer to MBIO structure</li>
</ul>
<p>The return values are:</p>
<ul>
<li>**store_ptr: pointer to storage data structure</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_deall()</h3>
<pre class="fragment">int mb_deall(
     int verbose,
     char *mbio_ptr,
     char **store_ptr,
     int *error);
</pre><p> The function mb_deall deallocates a format specific swath sonar data structure pointed to by *store_ptr. <br  />
</p>
<p>The input values are:</p>
<ul>
<li>*mbio_ptr: pointer to MBIO structure</li>
<li>*store_ptr: pointer to storage data structure</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_error()</h3>
<pre class="fragment">int mb_error(
     int error,
     int error,
     char **message);
</pre><p> Given the error value error, mb_format_inf returns a short error mes- sage in the string **message. The verbose value controls the standard error output verbosity of the function. The return status value sig- nals success if format is valid and failure otherwise.</p>
<h3>mb_navint_add()</h3>
<pre class="fragment">int mb_navint_add(
     int verbose,
     char *mbio_ptr,
     double time_d,
     double lon,
     double lat,
     int *error);
</pre><p> The function mb_navint_add adds a navigation fix to a circular buffer of navigation values maintained in the MBIO data structure pointed to by *mbio_ptr. This buffer is used to interpolate navigation for data formats where the navigation is asynchronous (where navigation and sur- vey pings come in different data records). <br  />
</p>
<p>The input values are:</p>
<ul>
<li>*mbio_ptr: pointer to MBIO structure</li>
<li>time_d: time of navigation fix in seconds since 1/1/70 00:00:00</li>
<li>lon: longitude (degrees)</li>
<li>lat: latitude (degrees)</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_navint_interp()</h3>
<pre class="fragment">int mb_navint_interp(
     int verbose,
     char *mbio_ptr,
     double time_d,
     double heading,
     double rawspeed,
     double *lon,
     double *lat,
     double *speed,
     int *error);
</pre><p> The function mb_navint_interp interpolates navigation to the time time_d using a circular buffer of navigation values maintained in the MBIO data structure pointed to by *mbio_ptr. This buffer is used to interpolate navigation for data formats where the navigation is asyn- chronous (where navigation and survey pings come in different data records). <br  />
</p>
<p>The input values are:</p>
<ul>
<li>*mbio_ptr: pointer to MBIO structure</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
<li>heading: heading in degrees</li>
<li>rawspeed: speed in km/hr (zero if not known)</li>
</ul>
<p>The return values are:</p>
<ul>
<li>*lon: longitude (degrees)</li>
<li>*lat: latitude (degrees)</li>
<li>*speed: speed made good in km/hr</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_attint_add()</h3>
<pre class="fragment">int mb_attint_add(
     int verbose,
     char *mbio_ptr,
     double time_d,
     double heave,
     double roll,
     double pitch,
     int *error);
</pre><p> The function mb_attint_add adds an attitude (heave, roll, pitch) data point to a circular buffer of attitude values maintained in the MBIO data structure pointed to by *mbio_ptr. This buffer is used to inter- polate attitude for data formats where the attitude is asynchronous (where attitude and survey pings come in different data records). <br  />
</p>
<p>The input values are:</p>
<ul>
<li>*mbio_ptr: pointer to MBIO structure</li>
<li>time_d: time of attitude in seconds since 1/1/70 00:00:00</li>
<li>heave: heave (meters, up +)</li>
<li>roll: roll (degrees, starboard up +)</li>
<li>pitch: pitch (degrees, forward up +)</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_attint_interp()</h3>
<pre class="fragment">int mb_attint_interp(
     int verbose,
     char *mbio_ptr,
     double time_d,
     double *heave,
     double *roll,
     double *pitch,
     int *error);
</pre><p> The function mb_attint_interp interpolates attitude (heave, roll, pitch) data to the time time_d using a circular buffer of attitude val- ues maintained in the MBIO data structure pointed to by *mbio_ptr. This buffer is used to interpolate attitude for data formats where the attitude is asynchronous (where attitude and survey pings come in dif- ferent data records). <br  />
</p>
<p>The input values are:</p>
<ul>
<li>*mbio_ptr: pointer to MBIO structure</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
</ul>
<p>The return values are:</p>
<ul>
<li>*heave: heave (meters, up +)</li>
<li>*roll: roll (degrees, starboard up +)</li>
<li>*pitch: pitch (degrees, forward up +)</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_hedint_add()</h3>
<pre class="fragment">int mb_hedint_add(
     int verbose,
     char *mbio_ptr,
     double time_d,
     double heading,
     int *error);
</pre><p> The function mb_hedint_add adds a heading point to a circular buffer of heading values maintained in the MBIO data structure pointed to by *mbio_ptr. This buffer is used to interpolate heading for data formats where the heading is asynchronous (where heading and survey pings come in different data records). <br  />
</p>
<p>The input values are:</p>
<ul>
<li>*mbio_ptr: pointer to MBIO structure</li>
<li>time_d: time of heading value in seconds since 1/1/70 00:00:00</li>
<li>heading: heading (degrees)</li>
</ul>
<p>The return values are:</p>
<ul>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_hedint_interp()</h3>
<pre class="fragment">int mb_hedint_interp(
     int verbose,
     char *mbio_ptr,
     double time_d,
     double *heading,
     int *error);
</pre><p> The function mb_hedint_interp interpolates heading to the time time_d using a circular buffer of heading values maintained in the MBIO data structure pointed to by *mbio_ptr. This buffer is used to interpolate heading for data formats where the heading is asynchronous (where head- ing and survey pings come in different data records). <br  />
</p>
<p>The input values are:</p>
<ul>
<li>*mbio_ptr: pointer to MBIO structure</li>
<li>time_d: time of current ping in seconds since 1/1/70 00:00:00</li>
</ul>
<p>The return values are:</p>
<ul>
<li>*heading: heading in degrees</li>
<li>error: error value</li>
</ul>
<p>A status value indicating success or failure is returned; the error value argument error passes more detailed information about failures.</p>
<h3>mb_get_double()</h3>
<pre class="fragment">int mb_get_double(
     double *value,
     char *str,
     int nchar);
</pre><p> The function mb_get_double parses the first nchar characters of the string *str for a floating point value, storing this value as a double in *value.</p>
<h3>mb_get_int()</h3>
<pre class="fragment">int mb_get_int(
     int *value,
     char *str,
     int nchar);
</pre><p> The function mb_get_int parses the first nchar characters of the string *str for an integer value, storing this value as a int in *value.</p>
<h3>mb_get_binary_short()</h3>
<pre class="fragment">int mb_get_binary_short(
     int swapped,
     void *buffer,
     short *value);
</pre><p> The function mb_get_binary_short extracts a short int value from the first two bytes pointed to by *buffer. If the boolean swapped is true, the byte order of *value is swapped.</p>
<h3>mb_get_binary_int()</h3>
<pre class="fragment">int mb_get_binary_int(
     int swapped,
     void *buffer,
     int *value);
</pre><p> The function mb_get_binary_int extracts an int value from the first four bytes pointed to by *buffer. If the boolean swapped is true, the byte order of *value is swapped.</p>
<h3>mb_get_binary_float()</h3>
<pre class="fragment">int mb_get_binary_float(
     int swapped,
     void *buffer,
     float *value);
</pre><p> The function mb_get_binary_float extracts a float value from the first four bytes pointed to by *buffer. If the boolean swapped is true, the byte order of *value is swapped.</p>
<h3>mb_get_binary_double()</h3>
<pre class="fragment">int mb_get_binary_double(
     int swapped,
     void *buffer,
     double *value);
</pre><p> The function mb_get_binary_double extracts a double value from the first eight bytes pointed to by *buffer. If the boolean swapped is true, the byte order of *value is swapped.</p>
<h3>mb_put_binary_short()</h3>
<pre class="fragment">int mb_put_binary_short(
     int swapped,
     short value,
     void *buffer);
</pre><p> The function mb_put_binary_short inserts a short int value into the first two bytes pointed to by *buffer. If the boolean swapped is true, the byte order of value is swapped.</p>
<h3>mb_put_binary_int()</h3>
<pre class="fragment">int mb_put_binary_int(
     int swapped,
     int value,
     void *buffer);
</pre><p> The function mb_put_binary_int inserts an int value into the first four bytes pointed to by *buffer. If the boolean swapped is true, the byte order of value is swapped.</p>
<h3>mb_put_binary_float()</h3>
<pre class="fragment">int mb_put_binary_float(
     int swapped,
     float value,
     void *buffer);
</pre><p> The function mb_put_binary_float inserts a float value into the first four bytes pointed to by *buffer. If the boolean swapped is true, the byte order of value is swapped.</p>
<h3>mb_put_binary_double()</h3>
<pre class="fragment">int mb_put_binary_double(
     int swapped,
     double value,
     void *buffer);
</pre><p> The function mb_put_binary_double inserts a double value into the first eight bytes pointed to by *buffer. If the boolean swapped is true, the byte order of value is swapped.</p>
<h3>mb_get_bounds()</h3>
<pre class="fragment">int mb_get_bounds(
     char *text,
     double *bounds);
</pre><p> The function mb_get_bounds parses the string *text and extracts geo- graphic bounds of a rectangular region in the form:</p>
<ul>
<li>bounds[0]: minimum longitude</li>
<li>bounds[1]: maximum longitude</li>
<li>bounds[2]: minimum latitude</li>
<li>bounds[3]: maximum latitude</li>
</ul>
<p>where *text is in the standard GMT bounds form. The longitude and lat- itude values in *text should separated by a '/' character, and individ- ual values may be represented in decimal degrees or in "dd:mm:ss" form (dd=degrees, mm=minutes, ss=seconds).</p>
<h3>mb_ddmmss_to_degree()</h3>
<pre class="fragment">double mb_ddmmss_to_degree(
     char *text);
</pre><p> The function mb_ddmmss_to_degree parses the string *text and extracts a decimal longitude or latitude value from a "dd:mm:ss" (dd=degrees, mm=minutes, ss=seconds) value.</p>
<h3>mb_takeoff_to_rollpitch()</h3>
<pre class="fragment">int mb_takeoff_to_rollpitch(
     int verbose,
     double theta,
     double phi,
     double *alpha,
     double *beta,
     int *error);
</pre><p> The function mb_takeoff_to_rollpitch translates angles from the "take-
off" coordinate reference frame to the "rollpitch" coordinate system. See the discussion of coordinate systems below.</p>
<h3>mb_rollpitch_to_takeoff()</h3>
<pre class="fragment">int mb_rollpitch_to_takeoff(
     int verbose,
     double alpha,
     double beta,
     double *theta,
     double *phi,
     int *error);
</pre><p> The function mb_rollpitch_to_takeoff translates angles from the "roll-
pitch" coordinate reference frame to the "takeoff" coordinate system. See the discussion of coordinate systems below.</p>
<h3>mb_double_compare()</h3>
<pre class="fragment">int mb_double_compare(
     double *a,
     double *b);
</pre><p> The function mb_double_compare is used with the qsort function. This function returns 1 if a &gt; b and -1 if a &lt;= b.</p>
<h3>mb_int_compare()</h3>
<pre class="fragment">int mb_int_compare(
     int *a,
     int *b);
</pre><p> The function mb_int_compare is used with the qsort function. This function returns 1 if a &gt; b and -1 if a &lt;= b.</p>
<h2>Coordinate Systems Used In MB-System</h2>
<h3>Introduction</h3>
<p>The coordinate systems described below are used within MB-System for calculations involving the location in space of depth, amplitude, or sidescan data. In all cases the origin of the coordinate system is at the center of the sonar transducers.</p>
<h3>Cartesian Coordinates</h3>
<p>The cartesian coordinate system used in MB-System is a bit odd because it is left-handed, as opposed to the right-handed x-y-z space conven- tionally used in most circumstances. With respect to the sonar (or the ship on which the sonar is mounted), the x-axis is athwartships with positive to starboard (to the right if facing forward), the y-axis is fore-aft with positive forward, and the z-axis is positive down.</p>
<h3>Spherical Coordinates</h3>
<p>There are two non-traditional spherical coordinate systems used in MB- System. The first, referred to here as takeoff angle coordinates, is useful for raytracing. The second, referred to here as roll-pitch coordinates, is useful for taking account of corrections to roll and pitch angles.</p>
<h4>Takeoff Angle Coordinates</h4>
<p>The three parameters are r, theta, and phi, where r is the distance from the origin, theta is the angle from vertical down (that is, from the positive z-axis), and phi is the angle from acrosstrack (the posi- tive x-axis) in the x-y plane. Note that theta is always positive; the direction in the x-y plane is given by phi. Raytracing is simple in these coordinates because the ray takeoff angle is just theta. However, applying roll or pitch corrections is complicated because roll and pitch have components in both theta and phi. </p><pre class="fragment">0 &lt;= theta &lt;= PI/2
-PI/2 &lt;= phi &lt;= 3*PI/2

x = rSIN(theta)COS(phi)
y = rSIN(theta)SIN(phi)
z = rCOS(theta)

theta = 0    ---&gt; vertical, along positive z-axis
theta = PI/2 ---&gt; horizontal, in x-y plane
phi = -PI/2  ---&gt; aft, in y-z plane with y negative
phi = 0      ---&gt; port, in x-z plane with x positive
phi = PI/2   ---&gt; forward, in y-z plane with y positive
phi = PI     ---&gt; starboard, in x-z plane with x negative
phi = 3*PI/2 ---&gt; aft, in y-z plane with y negative
</pre> <h4>Roll-Pitch Coordinates</h4>
<p>The three parameters are r, alpha, and beta, where r is the distance from the origin, alpha is the angle forward (effectively pitch angle), and beta is the angle from horizontal in the x-z plane (effectively roll angle). Applying a roll or pitch correction is simple in these coordinates because pitch is just alpha and roll is just beta. However, raytracing is complicated because deflection from vertical has compo- nents in both alpha and beta. </p><pre class="fragment">-PI/2 &lt;= alpha &lt;= PI/2
0 &lt;= beta &lt;= PI

x = rCOS(alpha)COS(beta)
y = rSIN(alpha)
z = rCOS(alpha)SIN(beta)

alpha = -PI/2 ---&gt; horizontal, in x-y plane with y negative
alpha = 0     ---&gt; ship level, zero pitch, in x-z plane
alpha = PI/2  ---&gt; horizontal, in x-y plane with y positive
beta = 0      ---&gt; starboard, along positive x-axis
beta = PI/2   ---&gt; in y-z plane rotated by alpha
beta = PI     ---&gt; port, along negative x-axis
</pre> <h3>SeaBeam Coordinates</h3>
<p>The per-beam parameters in the SB2100 data format include angle-from- vertical and angle-forward. Angle-from-vertical is the same as theta except that it is signed based on the acrosstrack direction (positive to starboard, negative to port). The angle-forward values are also defined slightly differently from phi, in that angle-forward is signed differently on the port and starboard sides. The SeaBeam 2100 External Interface Specifications document includes both discussion and figures illustrating the angle-forward value. To summarize: </p><pre class="fragment">Port:
theta = absolute value of angle-from-vertical

-PI/2 &lt;= phi &lt;= PI/2
is equivalent to
-PI/2 &lt;= angle-forward &lt;= PI/2

phi = -PI/2 ---&gt; angle-forward = -PI/2 (aft)
phi = 0     ---&gt; angle-forward = 0     (starboard)
phi = PI/2  ---&gt; angle-forward = PI/2  (forward)

Starboard:
theta = angle-from-vertical

PI/2 &lt;= phi &lt;= 3*PI/2
is equivalent to
-PI/2 &lt;= angle-forward &lt;= PI/2

phi = PI/2   ---&gt; angle-forward = -PI/2 (forward)
phi = PI     ---&gt; angle-forward = 0     (port)
phi = 3*PI/2 ---&gt; angle-forward = PI/2  (aft)
</pre> <h3>Usage of Coordinate Systems in MB-System</h3>
<p>Some sonar data formats provide angle values along with travel times. The angles are converted to takoff-angle coordinates regardless of the storage form of the particular data format. Currently, most data for- mats do not contain an alongtrack component to the position values; in these cases the conversion is trivial since phi = beta = 0 and theta = alpha. The angle and travel time values can be accessed using the MBIO function mb_ttimes. All angle values passed by MB-System functions are in degrees rather than radians.</p>
<p>The programs mbbath and mbvelocitytool use angles in take-off angle coordinates to do the raytracing. If roll and/or pitch corrections are to be made, the angles are converted to roll-pitch coordinates, cor- rected, and then converted back prior to raytracing.</p>
<h2>Beam Flags Used In MB-System</h2>
<p>MB-System uses arrays of 1-byte "beamflag" values to indicate beam data quality. Each beamflag value is actually an eight bit mask allowing fairly complicated information to be stored regarding each bathymetry value. In particular, beams may be flagged as bad, they may be selected as being of special interest, and one or more reasons for flagging or selection may be indicated. This scheme is very similar to the conven- tion used in the HMPS hydrographic data processing package and the SAIC Hydrobat package. The beam selection mechanism is not currently used by any MB-System programs.</p>
<p>The flag and select bits: </p><pre class="fragment">xxxxxx00 =&gt; This beam is neither flagged nor selected.
xxxxxx01 =&gt; This beam is flagged as bad and should be ignored.
xxxxxx10 =&gt; This beam has been selected.
</pre><p> Flagging modes: </p><pre class="fragment">00000001 =&gt; Flagged because no detection was made by the sonar.
xxxxx101 =&gt; Flagged by manual editing.
xxxx1x01 =&gt; Flagged by automatic filter.
xxx1xx01 =&gt; Flagged because uncertainty exceeds 1 X IHO standard.
xx1xxx01 =&gt; Flagged because uncertainty exceeds 2 X IHO standard.
x1xxxx01 =&gt; Flagged because footprint is too large
1xxxxx01 =&gt; Flagged by sonar as unreliable.
</pre><p> Selection modes: </p><pre class="fragment">00000010 =&gt; Selected, no reason specified.
xxxxx110 =&gt; Selected as least depth.
xxxx1x10 =&gt; Selected as average depth.
xxx1xx10 =&gt; Selected as maximum depth.
xx1xxx10 =&gt; Selected as location of sidescan contact.
x1xxxx10 =&gt; Selected, spare.
1xxxxx10 =&gt; Selected, spare.
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
